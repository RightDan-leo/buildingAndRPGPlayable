<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å¾®å…‰å®ˆå« - æ¨¡æ‹Ÿç»è¥ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
            touch-action: none;
            user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 1;
        }

        .stat-badge {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #555;
            border-radius: 8px;
            padding: 5px 10px;
            color: white;
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }

        .bar-container {
            width: 150px;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
            margin-left: 10px;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            width: 0%;
            transition: width 0.3s;
        }

        #objective-panel {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            padding: 10px 20px;
            border-radius: 20px;
            color: #00ffff;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            display: none;
            pointer-events: auto;
        }

        .build-label {
            position: absolute;
            transform: translate(-50%, -100%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid gold;
            color: gold;
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
            transition: opacity 0.2s;
            white-space: nowrap;
            z-index: 10;
        }

        #minimap {
            position: absolute;
            top: 120px;
            right: 20px;
            width: 140px;
            height: 140px;
            background: rgba(0, 20, 40, 0.85);
            border: 2px solid #00ffff;
            border-radius: 50%;
            display: none;
            overflow: hidden;
            z-index: 5;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            background-image: radial-gradient(circle, transparent 20%, rgba(0, 255, 255, 0.1) 21%, transparent 22%), radial-gradient(circle, transparent 50%, rgba(0, 255, 255, 0.1) 51%, transparent 52%);
        }

        .map-dot {
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #map-player {
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 10px solid #00ffff;
            background: transparent;
            top: 50%;
            left: 50%;
            z-index: 10;
            filter: drop-shadow(0 0 2px white);
        }

        #map-base {
            width: 12px;
            height: 12px;
            background: #d000ff;
            border: 2px solid white;
            z-index: 5;
            box-shadow: 0 0 8px #d000ff;
        }

        #restart-btn {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 50, 50, 0.8);
            border: 1px solid #ffaaaa;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            pointer-events: auto;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        #skill-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 20;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }

        #skill-container {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: stretch;
            width: 100%;
            padding: 0 10px;
        }

        .skill-card {
            background: linear-gradient(135deg, #2c3e50, #4ca1af);
            width: 45%;
            max-width: 300px;
            padding: 30px 10px;
            margin: 0 10px;
            border: 2px solid #fff;
            border-radius: 15px;
            color: white;
            text-align: center;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            transition: transform 0.1s, border-color 0.1s;
        }

        .skill-card:active {
            transform: scale(0.92);
            border-color: gold;
        }

        .skill-icon {
            font-size: 60px;
            margin-bottom: 15px;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
        }

        .skill-info {
            text-align: center;
        }

        .skill-title {
            font-size: 20px;
            color: #f1c40f;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .skill-desc {
            font-size: 14px;
            color: #ddd;
            line-height: 1.4;
        }

        #notify-text {
            position: absolute;
            top: 30%;
            width: 100%;
            text-align: center;
            font-size: 36px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 20px #ff00de;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            z-index: 5;
        }

        #joystick-zone {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 150px;
            height: 150px;
            z-index: 5;
            pointer-events: auto;
        }

        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div id="game-container"></div>
    <button id="restart-btn" onclick="game.resetGame()">â†º é‡æ–°å¼€å§‹</button>

    <!-- Ad Modal Structure -->
    <div id="ad-modal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:999; flex-direction:column; align-items:center; justify-content:center; color:white;">
        <h1 style="font-size:40px; text-shadow:0 0 10px gold; margin-bottom:20px;">ğŸ‰ ç¬¬ä¸‰å¤œé˜²å®ˆæˆåŠŸï¼</h1>
        <p style="font-size:20px; max-width:600px; text-align:center;">æ‚¨å·²è¯æ˜äº†è‡ªå·±æ˜¯çœŸæ­£çš„å¾®å…‰å®ˆå«ã€‚æƒ³è¦ä½“éªŒæ›´å®å¤§çš„æˆ˜äº‰ï¼Ÿ</p>
        <div
            style="background:#222; padding:20px; border:2px solid gold; border-radius:15px; margin:30px; text-align:center;">
            <h2 style="color:gold; margin-top:0;">ä¸‡é¾™è§‰é†’ (Call of Dragons)</h2>
            <p>å·¨å…½éœ‡é¢¤å¤§åœ°ï¼Œå†›å›¢é›†ç»“å¾…å‘½ï¼</p>
            <button onclick="window.open('https://callofdragons.farlightgames.com/', '_blank')"
                style="background:#e74c3c; color:white; border:none; padding:15px 40px; font-size:24px; border-radius:10px; cursor:pointer; font-weight:bold; box-shadow:0 5px #c0392b;">ç«‹å³ä¸‹è½½</button>
        </div>
        <button onclick="document.getElementById('ad-modal').style.display='none'; game.resetGame();"
            style="background:transparent; border:1px solid #aaa; color:#aaa; padding:10px 20px; border-radius:5px; cursor:pointer; margin-top:20px;">å…³é—­å¹¶é‡æ–°å¼€å§‹</button>
    </div>

    <div id="ui-layer">
        <div class="hud-top">
            <div style="display: flex; flex-direction: column;">
                <div class="stat-badge" style="border-color: #f1c40f;">
                    ğŸ’° <span id="gold-display">0</span>
                </div>
                <div class="stat-badge" style="border-color: #3498db;">
                    LV <span id="level-display">1</span>
                    <div class="bar-container">
                        <div id="xp-bar" class="bar-fill" style="background:#3498db;"></div>
                    </div>
                </div>
            </div>

            <div style="display: flex; flex-direction: column; align-items: flex-end;">
                <div class="stat-badge" id="base-hp-badge" style="border-color: #e74c3c;">
                    â¤ï¸ åŸºåœ° <span id="base-hp-text">100%</span>
                </div>
                <div class="stat-badge" id="energy-badge" style="border-color: #9b59b6; display:flex;">
                    âš¡ å……èƒ½
                    <div class="bar-container">
                        <div id="energy-bar" class="bar-fill" style="background:#9b59b6;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="objective-panel">å½“å‰ç›®æ ‡ï¼šæ¢ç´¢å¹¶æ”¶é›†èµ„æº</div>

        <div id="minimap">
            <div id="map-base" class="map-dot"></div>
            <div id="map-player" class="map-dot"></div>
        </div>

        <div id="notify-text">PHASE CHANGE</div>
    </div>

    <div id="world-labels"></div>
    <div id="joystick-zone">
        <div id="joystick-knob"></div>
    </div>

    <div id="skill-panel">
        <h2 style="color:white; text-shadow: 0 0 10px cyan; margin-bottom: 30px;">âš¡ å‡çº§! é€‰æ‹©å¼ºåŒ– âš¡</h2>
        <div id="skill-container"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const CONFIG = {
            baseChargeMax: 30,
            baseRadius: 10,
            colors: {
                nightBg: 0x111111, dayBg: 0x88ccff,
                groundNight: 0x222222, groundDay: 0x4caf50,
                buildGhost: 0x00ff00, buildLocked: 0xff0000
            },
            mapRange: 150
        };

        let STATE = {};

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(CONFIG.colors.nightBg, 20, 80);
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 40);
        camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const groundGeo = new THREE.PlaneGeometry(300, 300);
        const groundMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.groundNight });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const playerGroup = new THREE.Group();
        const playerBody = new THREE.Mesh(new THREE.ConeGeometry(2, 5, 8), new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x004444 }));
        playerBody.position.y = 2.5;
        playerGroup.add(playerBody);
        const bow = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 0.5), new THREE.MeshBasicMaterial({ color: 0xeeeeee }));
        bow.position.set(0, 3, 1.5);
        playerGroup.add(bow);
        playerGroup.castShadow = true;
        scene.add(playerGroup);

        // æŒ‡å¼•ç®­å¤´
        const guideArrow = new THREE.Group();
        const arCone = new THREE.Mesh(new THREE.ConeGeometry(1, 3, 8), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
        arCone.rotation.x = Math.PI / 2;
        arCone.position.z = 1.5;
        guideArrow.add(arCone);
        guideArrow.position.y = 5;
        playerGroup.add(guideArrow); // Parented to player to float above

        const baseGroup = new THREE.Group();
        const baseMesh = new THREE.Mesh(new THREE.OctahedronGeometry(6, 0), new THREE.MeshStandardMaterial({ color: 0x9b59b6, emissive: 0x550055 }));
        baseMesh.position.y = 8;
        baseGroup.add(baseMesh);
        const basePlatform = new THREE.Mesh(new THREE.CylinderGeometry(8, 10, 2, 8), new THREE.MeshStandardMaterial({ color: 0x555555 }));
        basePlatform.position.y = 1;
        baseGroup.add(basePlatform);
        const wallGroup = new THREE.Group();
        baseGroup.add(wallGroup);
        const turretGroup = new THREE.Group();
        baseGroup.add(turretGroup);
        scene.add(baseGroup);

        const buildSlotGroup = new THREE.Group();
        scene.add(buildSlotGroup);

        let mobs = [];
        let bullets = [];
        let particles = [];
        let items = [];
        let buildSlots = [];
        let soldiers = []; // Array to store soldier objects

        const game = {
            init: function () {
                this.resetState();
                this.startNight();
            },

            resetState: function () {
                // Balance: Audio System
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

                STATE = {
                    phase: 'NIGHT', gold: 0, level: 1, xp: 0, xpToNext: 20,
                    baseHp: 100, baseMaxHp: 100, baseEnergy: 0, energyPerKill: 2.5,
                    wave: 1, turretCount: 0, wallLevel: 0, soldierCount: 0,
                    pulseCannons: [], healers: [], empTowers: [],
                    player: { hp: 100, damage: 10, atkSpeed: 30, projectileCount: 1, speed: 0.4, pickupRange: 3.5 },
                    spawnTimer: 0, atkTimer: 0, turretTimer: 0, buildingTimer: 0, dayObjectiveMet: false,
                    buildsThisDay: 0,
                    flags: { wall: false, turret1: false, turret2: false, soldier: false },
                    bossSpawned: false
                };

                this.prices = { turret: 100, wall: 50, soldier: 150 };
                this.clearAllEntities();
                wallGroup.clear();
                turretGroup.clear();
                this.clearBuildSlots();
                this.clearSoldiers();
            },

            // ... (keeping existing functions until addXp)

            addXp: function (amount) {
                STATE.xp += amount;
                this.updateUI();
                this.checkLevelUp();
            },

            checkLevelUp: function () {
                // Prevent level up if already selecting skill
                if (STATE.phase === 'SKILL') return;

                if (STATE.xp >= STATE.xpToNext) {
                    STATE.xp -= STATE.xpToNext;
                    STATE.xpToNext = Math.floor(STATE.xpToNext * 1.5);
                    STATE.level++;
                    this.showSkillSelect();
                    this.updateUI();
                }
            },

            showSkillSelect: function () {
                const oldPhase = STATE.phase;
                STATE.phase = 'SKILL';
                const panel = document.getElementById('skill-panel');
                const container = document.getElementById('skill-container');
                container.innerHTML = '';
                panel.style.display = 'flex';

                const skills = [
                    { name: "å¼ºåŠ›å°„å‡»", icon: "ğŸ’¥", desc: "ä¼¤å®³ +30%", act: () => STATE.player.damage *= 1.3 },
                    { name: "æ€¥é€Ÿå°„å‡»", icon: "ğŸŒªï¸", desc: "æ”»é€Ÿ +20%", act: () => STATE.player.atkSpeed = Math.max(5, STATE.player.atkSpeed * 0.8) },
                    { name: "å¤šé‡ç®­çŸ¢", icon: "ğŸ¹", desc: "ç®­çŸ¢æ•°é‡ +1", act: () => STATE.player.projectileCount++ }
                ];

                const choices = skills.sort(() => 0.5 - Math.random()).slice(0, 2);
                choices.forEach(skill => {
                    const card = document.createElement('div');
                    card.className = 'skill-card';
                    card.innerHTML = `<div class="skill-icon">${skill.icon}</div><div class="skill-info"><div class="skill-title">${skill.name}</div><div class="skill-desc">${skill.desc}</div></div>`;
                    card.onclick = () => {
                        skill.act();
                        panel.style.display = 'none';
                        STATE.phase = oldPhase;
                        // Check if we have enough XP for another level
                        this.checkLevelUp();
                    };
                    container.appendChild(card);
                });
            },

            clearAllEntities: function () {
                mobs.forEach(m => scene.remove(m.mesh)); mobs = [];
                bullets.forEach(b => scene.remove(b.mesh)); bullets = [];
                items.forEach(i => scene.remove(i.mesh)); items = [];
                particles.forEach(p => scene.remove(p.mesh)); particles = [];
            },

            clearBuildSlots: function () {
                buildSlots.forEach(s => {
                    if (s.labelEl) s.labelEl.remove();
                    if (s.mesh) buildSlotGroup.remove(s.mesh);
                });
                buildSlots = [];
            },

            clearSoldiers: function () {
                soldiers.forEach(s => scene.remove(s.mesh));
                soldiers = [];
            },

            resetGame: function () {
                document.getElementById('skill-panel').style.display = 'none';
                this.resetState();
                this.startNight();
                this.notify("æ¸¸æˆå·²é‡ç½®");
            },

            startNight: function () {
                STATE.phase = 'NIGHT';
                STATE.baseEnergy = 0;
                STATE.bossSpawned = false; // Reset boss flag each night (though only used for W3)

                if (STATE.wave === 1) { CONFIG.baseChargeMax = 20; STATE.energyPerKill = 2.5; } // Reduced from 30 (-33%)
                else { CONFIG.baseChargeMax = 70; STATE.energyPerKill = 3; } // Reduced from 100 (-30%)

                scene.background = new THREE.Color(CONFIG.colors.nightBg);
                scene.fog.color.setHex(CONFIG.colors.nightBg);
                scene.fog.near = 20; scene.fog.far = 80; // Dense fog for night atmosphere
                ground.material.color.setHex(CONFIG.colors.groundNight);
                playerGroup.position.set(0, 0, 10);
                baseGroup.visible = true;
                buildSlotGroup.visible = false;
                guideArrow.visible = false; // Hide arrow at night
                camera.position.set(0, 50, 40);

                document.getElementById('minimap').style.display = 'none';
                document.getElementById('objective-panel').style.display = 'none';
                document.getElementById('energy-badge').style.display = 'flex';
                buildSlots.forEach(s => { if (s.labelEl) s.labelEl.style.display = 'none'; });

                // Recall Soldiers
                this.recallSoldiers();

                this.notify(STATE.wave > 1 ? "âš ï¸ BOSS å‡ºç°!" : "âš ï¸ æ€ªç‰©å›´åŸ!");
                this.updateUI();
            },

            startDay: function () {
                STATE.phase = 'DAY';
                STATE.dayObjectiveMet = false;
                STATE.buildsThisDay = 0;

                scene.background = new THREE.Color(CONFIG.colors.dayBg);
                scene.fog.color.setHex(CONFIG.colors.dayBg);
                scene.fog.near = 50; scene.fog.far = 200; // Reduce fog for day visibility
                ground.material.color.setHex(CONFIG.colors.groundDay);
                playerGroup.position.set(0, 0, 20);
                camera.position.set(0, 50, 60);

                baseGroup.visible = true;
                buildSlotGroup.visible = true;
                // guideArrow.visible = true; // REMOVED per user request

                document.getElementById('minimap').style.display = 'block';
                document.getElementById('energy-badge').style.display = 'none';
                document.getElementById('objective-panel').style.display = 'block';
                document.getElementById('objective-panel').innerText = `Day ${STATE.wave}: æœé›†é‡‘å¸ï¼Œå»ºè®¾å®¶å›­`;

                this.generateWilds();
                this.setupBuildSlots();
                this.deploySoldiers(); // Soldiers start working
                this.notify("â˜€ï¸ å¤©äº®äº†ï¼æœé›†é‡‘å¸ï¼Œå»ºè®¾å®¶å›­ï¼");
            },

            // ...

            updateGuideArrow: function () {
                // Feature disabled by user request
                guideArrow.visible = false;
                return;
            },

            generateWilds: function () {
                for (let i = 0; i < 30 + STATE.wave * 10; i++) {
                    // Changed to Octahedron to look like Gems/Crystals instead of Enemy Boxes
                    const bx = new THREE.Mesh(new THREE.OctahedronGeometry(1), new THREE.MeshStandardMaterial({ color: 0xffd700 }));
                    const angle = Math.random() * Math.PI * 2;
                    const r = 40 + Math.random() * 80;
                    const x = Math.sin(angle) * r;
                    const z = Math.cos(angle) * r;
                    bx.position.set(x, 1, z);
                    bx.rotation.y = Math.random();
                    scene.add(bx);
                    items.push({ mesh: bx, val: 30 + Math.floor(Math.random() * 30) });
                }
            },

            update: function () {
                if (STATE.phase === 'SKILL') return;
                this.handleInput();

                if (STATE.phase === 'DAY') {
                    camera.position.x = playerGroup.position.x;
                    camera.position.z = playerGroup.position.z + 40;
                    camera.lookAt(playerGroup.position);

                    const range = CONFIG.mapRange;
                    const pctX = 50 + (playerGroup.position.x / range) * 50;
                    const pctY = 50 + (playerGroup.position.z / range) * 50;
                    document.getElementById('map-player').style.left = pctX + '%';
                    document.getElementById('map-player').style.top = pctY + '%';

                    this.checkBuildInteraction();
                    this.updateSoldiers();
                    // this.updateGuideArrow(); // REMOVED

                    // Rotate build slots for effect
                    if (buildSlotGroup.visible) {
                        buildSlotGroup.children.forEach(child => {
                            child.rotation.z -= 0.02; // Rotate around Z because it's rotated X -90
                        });
                    }

                    for (let i = items.length - 1; i >= 0; i--) {
                        const it = items[i];
                        if (playerGroup.position.distanceTo(it.mesh.position) < STATE.player.pickupRange) {
                            STATE.gold += it.val;
                            this.createExplosion(it.mesh.position, 0xffff00, 1.5);
                            this.playSound('collect'); // Audio
                            scene.remove(it.mesh);
                            items.splice(i, 1);
                            this.updateUI();
                        }
                    }
                }

                if (STATE.phase === 'NIGHT') {
                    // Spawn Boss on Wave 3 start
                    if (STATE.wave === 3 && !STATE.bossSpawned) {
                        this.spawnBoss();
                        STATE.bossSpawned = true;
                        this.notify("âš ï¸ è­¦å‘Š: å·¨å‹ BOSS æŠŠå®ˆå…³åº•!");
                    }

                    STATE.spawnTimer++;
                    // Slower spawn rate: Wave 1 = 60 frames (1s), Higher waves = faster but capped at 20frames
                    let spawnRate = (STATE.wave === 1) ? 60 : Math.max(20, 50 - STATE.wave * 3);
                    if (STATE.spawnTimer > spawnRate) {
                        this.spawnMob();
                        STATE.spawnTimer = 0;
                    }

                    STATE.turretTimer++;
                    if (turretGroup.children.length > 0 && STATE.turretTimer > 40) {
                        turretGroup.children.forEach(t => {
                            const target = this.getClosestMob(new THREE.Vector3(0, 0, 0));
                            if (target) {
                                const tPos = new THREE.Vector3();
                                t.children[1].getWorldPosition(tPos);
                                t.lookAt(target.mesh.position);
                                this.spawnBullet(tPos, target.mesh.position, 0xffff00, true);
                            }
                        });
                        STATE.turretTimer = 0;
                    }

                    this.logicCombat();
                }

                this.logicBuildings(); // Run passive effects (Miners, Healers, EMP)

                this.updateEntities();

                if (baseGroup.visible) {
                    baseMesh.rotation.y += 0.01;
                    baseMesh.position.y = 8 + Math.sin(Date.now() * 0.002);
                }
            },

            logicBuildings: function () {
                STATE.buildingTimer++;
                // Pulse Cannons: AOE Damage every 120 frames (~2s)
                if (STATE.buildingTimer % 120 === 0 && STATE.pulseCannons.length > 0) {
                    STATE.pulseCannons.forEach(p => {
                        this.createExplosion(p.pos, 0x00ffff, 4); // Visual Pulse
                        // Finding mobs in range
                        for (let j = mobs.length - 1; j >= 0; j--) {
                            const m = mobs[j];
                            if (m.mesh.position.distanceTo(p.pos) < 25) {
                                this.hitMob(j, 30); // 30 Damage
                                this.createExplosion(m.mesh.position, 0x0000ff, 0.8);
                            }
                        }
                    });
                }

                // Healers: +2% HP every 600 frames (~10s)
                if (STATE.buildingTimer % 600 === 0 && STATE.healers.length > 0) {
                    const heal = STATE.healers.length * 2;
                    if (STATE.baseHp < STATE.baseMaxHp) {
                        STATE.baseHp = Math.min(STATE.baseMaxHp, STATE.baseHp + heal);
                        this.notify(`ç»´ä¿®ç«™: åŸºåœ°ä¿®å¤ +${heal}%`);
                        this.updateUI();
                    }
                }

                // EMP: Stun every 180 frames (~3s)
                if (STATE.buildingTimer % 180 === 0 && STATE.empTowers.length > 0) {
                    STATE.empTowers.forEach(t => {
                        this.createExplosion(t.pos, 0x00ffff, 3); // Visual Pulse
                        mobs.forEach(m => {
                            if (m.mesh.position.distanceTo(t.pos) < 25) {
                                m.stun = 60; // Stun for 1s
                                this.createExplosion(m.mesh.position, 0x0000ff, 0.5);
                            }
                        });
                    });
                }
            },

            triggerDaybreak: function () {
                for (let i = 0; i < 50; i++) this.createExplosion(new THREE.Vector3(0, 0, 0), 0xffffff, 2);
                mobs.forEach(m => scene.remove(m.mesh)); mobs = [];
                // Check Ad Condition: End of Wave 3 Night
                if (STATE.wave === 3 && STATE.phase === 'NIGHT') {
                    document.getElementById('ad-modal').style.display = 'flex';
                    this.playSound('levelup');
                } else {
                    setTimeout(() => { this.startDay(); }, 2000);
                }
            },

            playSound: function (type) {
                if (!this.audioCtx) return;
                const osc = this.audioCtx.createOscillator();
                const gain = this.audioCtx.createGain();
                osc.connect(gain);
                gain.connect(this.audioCtx.destination);

                const now = this.audioCtx.currentTime;

                if (type === 'shoot') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                }
                else if (type === 'hit') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                }
                else if (type === 'build') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.linearRampToValueAtTime(800, now + 0.2);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                }
                else if (type === 'levelup') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.setValueAtTime(600, now + 0.1);
                    osc.frequency.setValueAtTime(900, now + 0.2);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.linearRampToValueAtTime(0, now + 1);
                    osc.start(now);
                    osc.stop(now + 1);
                }
                else if (type === 'collect') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1000, now);
                    osc.frequency.exponentialRampToValueAtTime(1500, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                }
            },

            autoEndDay: function () {
                STATE.wave++;
                this.notify("ğŸŒ™ å»ºè®¾å®Œæˆï¼Œé»‘å¤œé™ä¸´ï¼");
                this.playSound('build'); // Sound
                setTimeout(() => { this.startNight(); }, 2000);
            },

            setupBuildSlots: function () {
                this.clearBuildSlots();

                // Day 1: Wall + Turret 1 (Right)
                if (STATE.wave >= 1) {
                    if (!STATE.flags.wall) this.addBuildSlot(new THREE.Vector3(0, 0, 15), 'wall', 'åŠ å›ºåŸå¢™', 50, 'wall');
                    if (!STATE.flags.turret1) this.addBuildSlot(new THREE.Vector3(15, 0, 0), 'turret', 'å»ºé€ é˜²å¾¡å¡”', 100, 'turret1');

                    // Allow previous unbuilt if any? (Implied by checking flags)
                }

                // Day 2: Soldier + Pulse Cannon (Left) + Healer (Back)
                if (STATE.wave >= 2) {
                    if (!STATE.flags.soldier) this.addBuildSlot(new THREE.Vector3(0, 0, -15), 'soldier', 'æ‹›å‹Ÿå£«å…µ', 150, 'soldier');
                    // Replaced 2nd Turret with Pulse Cannon (Left)
                    this.addBuildSlot(new THREE.Vector3(-15, 0, 0), 'pulse', 'ç”µç£ç‚®', 250);
                    // Added Healer (Back Left)
                    this.addBuildSlot(new THREE.Vector3(-10, 0, -10), 'healer', 'ç»´ä¿®ç«™', 150);
                }

                // Day 3+: Advanced Buildings (EMP)
                if (STATE.wave >= 3) {
                    // Pulse and Healer moved to Day 2
                    // Updated Position: Left of Main City (-25, 0, 0) instead of (0, 0, 25)
                    this.addBuildSlot(new THREE.Vector3(-25, 0, 0), 'emp', 'ç”µç£å¹²æ‰°å¡”', 300);
                }
            },

            addBuildSlot: function (pos, type, name, cost, id = null) {
                // Changed to Ring for "Ground Circle" look
                const geo = new THREE.RingGeometry(2.5, 3, 32);
                const mat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.buildGhost, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.x = -Math.PI / 2; // Lay flat on ground
                mesh.position.copy(pos);
                // Lift slightly above ground to avoid z-fighting
                mesh.position.y = 0.1;

                buildSlotGroup.add(mesh);
                const label = document.createElement('div');
                label.className = 'build-label';
                label.innerHTML = `${name}<br>ğŸ’° ${cost}`;
                document.getElementById('world-labels').appendChild(label);
                buildSlots.push({ mesh, type, name, cost, built: false, labelEl: label, basePos: pos.clone(), id });
            },

            checkBuildInteraction: function () {
                let closeSlot = null;
                buildSlots.forEach(s => {
                    if (s.built) return; // Special logic for soldier? If repeatable

                    if (s.type === 'soldier') { // Soldier slot is repeatable
                        // Reset 'built' status for soldier slot if we want to build multiple
                        // But for now let's keep it simple: One build per day per slot for gameplay pacing
                    }

                    const d = playerGroup.position.distanceTo(s.mesh.position);
                    const screenPos = s.mesh.position.clone().project(camera);
                    const x = (screenPos.x * .5 + .5) * window.innerWidth;
                    const y = (-(screenPos.y * .5) + .5) * window.innerHeight;
                    s.labelEl.style.left = x + 'px'; s.labelEl.style.top = y + 'px';
                    s.labelEl.style.display = 'block';

                    if (d < 5) {
                        s.mesh.material.opacity = 0.8;
                        if (STATE.gold >= s.cost) {
                            s.labelEl.style.borderColor = '#00ff00'; s.labelEl.style.color = '#00ff00';
                            s.labelEl.innerHTML = `${s.name}<br>âœ… å»ºé€  (åœç•™)`;
                            closeSlot = s;
                        } else {
                            s.labelEl.style.borderColor = 'red'; s.labelEl.style.color = 'red';
                        }
                    } else {
                        s.mesh.material.opacity = 0.3;
                        s.labelEl.style.borderColor = 'gold'; s.labelEl.style.color = 'gold';
                        s.labelEl.innerHTML = `${s.name}<br>ğŸ’° ${s.cost}`;
                    }
                });

                if (closeSlot && !joystick.active && STATE.gold >= closeSlot.cost) {
                    this.performBuild(closeSlot);
                }
            },

            performBuild: function (slot) {
                STATE.gold -= slot.cost;
                STATE.buildsThisDay++;

                this.createExplosion(slot.mesh.position, 0x00ff00, 2);
                this.notify(`å»ºé€ æˆåŠŸ: ${slot.name}`);

                if (slot.type === 'turret') {
                    STATE.turretCount++;
                    // Identify which turret it is based on ID (simple check)
                    if (slot.id === 'turret1') STATE.flags.turret1 = true;
                    if (slot.id === 'turret2') STATE.flags.turret2 = true;

                    const tBase = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 2, 1, 8), new THREE.MeshStandardMaterial({ color: 0x555555 }));
                    const tCannon = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 3), new THREE.MeshStandardMaterial({ color: 0x0088ff }));
                    tCannon.position.y = 1.5; tCannon.position.z = 1;
                    const tm = new THREE.Group(); tm.add(tBase); tm.add(tCannon);
                    tm.position.copy(slot.mesh.position);
                    turretGroup.add(tm);
                    slot.built = true; slot.mesh.visible = false; slot.labelEl.style.display = 'none';
                }
                else if (slot.type === 'wall') {
                    STATE.wallLevel++;
                    STATE.flags.wall = true;
                    // Changed to Solid material, slightly transparent
                    const w = new THREE.Mesh(new THREE.CylinderGeometry(15, 15, 4, 32, 1, true), new THREE.MeshStandardMaterial({
                        color: 0x00ffff,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.6,
                        emissive: 0x004444
                    }));
                    w.position.set(0, 2, 0); // Wall is centered on base
                    wallGroup.add(w);
                    slot.built = true; slot.mesh.visible = false; slot.labelEl.style.display = 'none';
                }
                else if (slot.type === 'soldier') {
                    STATE.flags.soldier = true;
                    // Spawn 2 soldiers immediately
                    this.spawnSoldier();
                    this.spawnSoldier();
                    this.notify("å·²æ‹›å‹Ÿ 2 åå£«å…µï¼");
                    // Do NOT hide slot, allow buying more? Or hide for this day?
                    // Let's hide for this day to keep it simple.
                    slot.built = true; slot.mesh.visible = false; slot.labelEl.style.display = 'none';
                }
                else if (slot.type === 'pulse') {
                    STATE.pulseCannons.push({ level: 1, pos: slot.mesh.position.clone() });
                    const p = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 6), new THREE.MeshStandardMaterial({ color: 0x9b59b6 }));
                    p.position.copy(slot.mesh.position); p.position.y = 3;
                    const coil = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.2, 8, 16), new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00aaaa }));
                    coil.rotation.x = Math.PI / 2; coil.position.y = 2;
                    p.add(coil);
                    baseGroup.add(p);
                    slot.built = true; slot.mesh.visible = false; slot.labelEl.style.display = 'none';
                }
                else if (slot.type === 'healer') {
                    STATE.healers.push({ level: 1 });
                    const h = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), new THREE.MeshStandardMaterial({ color: 0x2ecc71 }));
                    h.position.copy(slot.mesh.position); h.position.y = 1.5;
                    const cross = new THREE.Mesh(new THREE.BoxGeometry(3.2, 1, 1), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                    const cross2 = new THREE.Mesh(new THREE.BoxGeometry(1, 3.2, 1), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                    h.add(cross); h.add(cross2);
                    baseGroup.add(h);
                    slot.built = true; slot.mesh.visible = false; slot.labelEl.style.display = 'none';
                }
                else if (slot.type === 'emp') {
                    STATE.empTowers.push({ level: 1, pos: slot.mesh.position.clone() });
                    const e = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 8), new THREE.MeshStandardMaterial({ color: 0x3498db }));
                    e.position.copy(slot.mesh.position); e.position.y = 4;
                    const ring = new THREE.Mesh(new THREE.TorusGeometry(2, 0.2, 8, 32), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
                    ring.rotation.x = Math.PI / 2; ring.position.y = 2;
                    e.add(ring);
                    baseGroup.add(e);
                    slot.built = true; slot.mesh.visible = false; slot.labelEl.style.display = 'none';
                }

                if (!STATE.dayObjectiveMet && STATE.buildsThisDay >= 2) {
                    STATE.dayObjectiveMet = true;
                    setTimeout(() => this.autoEndDay(), 2000);
                }
                this.updateUI();
            },

            spawnSoldier: function () {
                STATE.soldierCount++;
                const geo = new THREE.BoxGeometry(1, 2, 1);
                const mat = new THREE.MeshStandardMaterial({ color: 0x4488ff }); // Blue soldiers
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(0, 1, 0);
                scene.add(mesh);
                soldiers.push({ mesh, state: 'IDLE', target: null, bag: 0, speed: 0.25 });
                this.notify("æ–°å£«å…µå·²å°±ç»ªï¼");
            },

            deploySoldiers: function () {
                // Ensure all soldiers are visible and active
                soldiers.forEach(s => { s.mesh.visible = true; s.state = 'IDLE'; s.mesh.position.set(0, 1, 0); });
            },

            recallSoldiers: function () {
                // Hide soldiers at night
                soldiers.forEach(s => { s.mesh.visible = false; });
            },

            updateSoldiers: function () {
                if (STATE.phase !== 'DAY') return;

                soldiers.forEach(s => {
                    // AI Logic
                    if (s.state === 'IDLE') {
                        // Find nearest item
                        let closest = null; let minD = 9999;
                        items.forEach(it => {
                            if (it.claimed) return; // Skip items being targeted by other soldiers? (Simple: don't check claimed)
                            const d = s.mesh.position.distanceTo(it.mesh.position);
                            if (d < minD) { minD = d; closest = it; }
                        });

                        if (closest) {
                            s.target = closest;
                            // Mark item as 'targeted' effectively so others prefer others? 
                            // For simple implementation, let them swarm or just independent
                            s.state = 'MOVING_TO_RESOURCE';
                        } else {
                            // No items, return base
                            s.state = 'MOVING_TO_BASE';
                        }
                    }
                    else if (s.state === 'MOVING_TO_RESOURCE') {
                        if (!s.target || !items.includes(s.target)) { s.state = 'IDLE'; return; } // Target gone

                        const dir = new THREE.Vector3().subVectors(s.target.mesh.position, s.mesh.position).normalize();
                        s.mesh.position.add(dir.multiplyScalar(s.speed));
                        s.mesh.lookAt(s.target.mesh.position);

                        if (s.mesh.position.distanceTo(s.target.mesh.position) < 1.5) {
                            // Collect
                            scene.remove(s.target.mesh);
                            items = items.filter(it => it !== s.target);
                            STATE.gold += s.target.val;
                            this.notify(`å£«å…µè·å¾— +${s.target.val} G`);
                            this.playSound('collect'); // Audio
                            this.updateUI(); // Immediate gold? or manual return? Spec says "help gather", immediate is more satisfying for now
                            s.item = null;
                            s.state = 'IDLE'; // Find next
                        }
                    }
                });
            },



            spawnMob: function () {
                const group = new THREE.Group();
                const geo = new THREE.BoxGeometry(2, 2, 2);
                const mat = new THREE.MeshStandardMaterial({ color: 0xff4444 });
                const body = new THREE.Mesh(geo, mat);
                body.castShadow = true;
                group.add(body);

                // Health Bar
                const hpBg = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 0.05), new THREE.MeshBasicMaterial({ color: 0x550000 }));
                hpBg.position.y = 2.5;
                group.add(hpBg);

                const hpFgGeo = new THREE.BoxGeometry(2, 0.2, 0.05);
                hpFgGeo.translate(1, 0, 0); // Pivot to left
                const hpFg = new THREE.Mesh(hpFgGeo, new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
                hpFg.position.set(-1, 2.5, 0.02); // Start at left edge, slightly in front
                group.add(hpFg);

                const angle = Math.random() * Math.PI * 2;
                const r = 60;
                group.position.set(Math.sin(angle) * r, 1, Math.cos(angle) * r);
                scene.add(group);

                const maxHp = 20 + STATE.wave * 5;
                mobs.push({ mesh: group, hp: maxHp, maxHp: maxHp, hpBar: hpFg, speed: 0.15 + STATE.wave * 0.01, isBoss: false });
            },

            spawnBoss: function () {
                const group = new THREE.Group();
                const geo = new THREE.DodecahedronGeometry(5);
                const mat = new THREE.MeshStandardMaterial({ color: 0x8e44ad, emissive: 0x4b0082 });
                const body = new THREE.Mesh(geo, mat);
                body.castShadow = true;
                group.add(body);

                // Boss Health Bar (Larger)
                const hpBg = new THREE.Mesh(new THREE.BoxGeometry(6, 0.5, 0.1), new THREE.MeshBasicMaterial({ color: 0x550000 }));
                hpBg.position.y = 6.5;
                group.add(hpBg);

                const hpFgGeo = new THREE.BoxGeometry(6, 0.5, 0.1);
                hpFgGeo.translate(3, 0, 0);
                const hpFg = new THREE.Mesh(hpFgGeo, new THREE.MeshBasicMaterial({ color: 0xff0000 })); // Red bar for boss
                hpFg.position.set(-3, 6.5, 0.05);
                group.add(hpFg);

                const angle = Math.random() * Math.PI * 2;
                const r = 60;
                group.position.set(Math.sin(angle) * r, 5, Math.cos(angle) * r);
                scene.add(group);

                const maxHp = 500;
                mobs.push({ mesh: group, hp: maxHp, maxHp: maxHp, hpBar: hpFg, speed: 0.08, isBoss: true });
            },

            logicCombat: function () {
                STATE.atkTimer++;
                if (STATE.atkTimer >= STATE.player.atkSpeed) {
                    const target = this.getClosestMob(playerGroup.position, 25);
                    if (target) {
                        playerGroup.lookAt(target.mesh.position);
                        for (let i = 0; i < STATE.player.projectileCount; i++) {
                            const offset = (i - (STATE.player.projectileCount - 1) / 2) * 0.2;
                            this.spawnBullet(playerGroup.position, target.mesh.position, 0x00ffff, false, offset);
                        }
                        this.playSound('shoot'); // Audio
                        STATE.atkTimer = 0;
                    }
                }

                mobs.forEach(m => {
                    const dest = new THREE.Vector3(0, 0, 0);
                    // Determine stop radius: Wall (15) or Base (10)
                    const stopRadius = (STATE.wallLevel > 0) ? 15 : CONFIG.baseRadius;

                    if (m.stun && m.stun > 0) {
                        m.stun--;
                        return; // Skip movement if stunned
                    }

                    const dist = m.mesh.position.length();

                    if (dist > stopRadius) {
                        const dir = new THREE.Vector3().subVectors(dest, m.mesh.position).normalize();
                        m.mesh.position.add(dir.multiplyScalar(m.speed));
                        m.mesh.lookAt(dest);
                    } else {
                        // Attack Base/Wall
                        if (STATE.baseHp > 0) {
                            STATE.baseHp -= 0.1;
                            if (Math.random() < 0.1) this.createExplosion(m.mesh.position, 0xff0000, 0.5);
                            this.updateUI();
                        }
                    }
                });
            },

            updateEntities: function () {
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    b.mesh.position.add(b.vel);
                    b.life--;
                    let hit = false;
                    for (let j = mobs.length - 1; j >= 0; j--) {
                        const m = mobs[j];
                        if (b.mesh.position.distanceTo(m.mesh.position) < 2) {
                            this.hitMob(j, b.isTurret ? 20 : STATE.player.damage);
                            hit = true;
                            break;
                        }
                    }
                    if (hit || b.life <= 0) { scene.remove(b.mesh); bullets.splice(i, 1); }
                }

                this.updateParticles();
            },

            spawnBullet: function (start, end, color, isTurret, angleOffset = 0) {
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshBasicMaterial({ color: color }));
                mesh.position.copy(start);
                scene.add(mesh);
                const dir = new THREE.Vector3().subVectors(end, start).normalize();
                if (angleOffset !== 0) dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), angleOffset);
                bullets.push({ mesh, vel: dir.multiplyScalar(1.0), life: 60, isTurret });
            },

            hitMob: function (index, dmg) {
                const m = mobs[index];
                m.hp -= dmg;

                // Update Health Bar
                const pct = Math.max(0, m.hp / m.maxHp);
                if (m.hpBar) m.hpBar.scale.x = pct;

                if (m.hp <= 0) {
                    scene.remove(m.mesh);
                    mobs.splice(index, 1);
                    this.createExplosion(m.mesh.position, 0xffaa00, 1);
                    this.playSound('hit'); // Audio
                    this.addXp(10);
                    if (STATE.phase === 'NIGHT') {
                        STATE.baseEnergy += STATE.energyPerKill;
                        if (STATE.baseEnergy >= CONFIG.baseChargeMax) this.triggerDaybreak();
                    }
                    this.updateUI();
                }
            },



            handleInput: function () {
                let dx = joystick.x; let dy = joystick.y;
                if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
                    playerGroup.position.x += dx * STATE.player.speed;
                    playerGroup.position.z += dy * STATE.player.speed;
                    playerGroup.rotation.y = Math.atan2(-dx, -dy);
                }
            },

            getClosestMob: function (pos, range = 999) {
                let closest = null; let minDst = range;
                mobs.forEach(m => {
                    const d = pos.distanceTo(m.mesh.position);
                    if (d < minDst) { minDst = d; closest = m; }
                });
                return closest;
            },

            updateUI: function () {
                document.getElementById('gold-display').innerText = STATE.gold;
                document.getElementById('level-display').innerText = STATE.level;
                document.getElementById('xp-bar').style.width = (STATE.xp / STATE.xpToNext * 100) + '%';
                document.getElementById('base-hp-text').innerText = Math.floor(STATE.baseHp) + '%';
                const energyPct = Math.min(100, (STATE.baseEnergy / CONFIG.baseChargeMax) * 100);
                document.getElementById('energy-bar').style.width = energyPct + '%';
            },

            notify: function (msg) {
                const el = document.getElementById('notify-text');
                el.innerText = msg;
                el.style.opacity = 1;
                el.style.top = "30%";
                setTimeout(() => { el.style.opacity = 0; el.style.top = "20%"; }, 2000);
            },

            createExplosion: function (pos, color, scale = 1) {
                for (let i = 0; i < 8; i++) {
                    const p = new THREE.Mesh(new THREE.BoxGeometry(0.5 * scale, 0.5 * scale, 0.5 * scale), new THREE.MeshBasicMaterial({ color: color }));
                    p.position.copy(pos);
                    scene.add(p);
                    particles.push({ mesh: p, vel: new THREE.Vector3((Math.random() - 0.5), Math.random(), (Math.random() - 0.5)).multiplyScalar(0.5 * scale), life: 30 });
                }
            },

            updateParticles: function () {
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.mesh.position.add(p.vel);
                    p.vel.y -= 0.03;
                    p.life--;
                    if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
                }
            }
        };

        const joystick = { x: 0, y: 0, active: false };
        const joyZone = document.getElementById('joystick-zone');
        const joyKnob = document.getElementById('joystick-knob');
        let joyStart = { x: 0, y: 0 };

        joyZone.addEventListener('touchstart', e => {
            joystick.active = true;
            const t = e.touches[0];
            const r = joyZone.getBoundingClientRect();
            joyStart = { x: r.left + r.width / 2, y: r.top + r.height / 2 };
            updateJoy(t.clientX, t.clientY);
        });
        joyZone.addEventListener('touchmove', e => { if (joystick.active) updateJoy(e.touches[0].clientX, e.touches[0].clientY); });
        const endJoy = () => { joystick.active = false; joystick.x = 0; joystick.y = 0; joyKnob.style.transform = `translate(-50%, -50%)`; };
        joyZone.addEventListener('touchend', endJoy);

        function updateJoy(cx, cy) {
            let dx = cx - joyStart.x;
            let dy = cy - joyStart.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const max = 50;
            if (dist > max) { dx = (dx / dist) * max; dy = (dy / dist) * max; }
            joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            joystick.x = dx / max; joystick.y = dy / max;
        }

        const keys = {};
        window.onkeydown = e => keys[e.key] = true;
        window.onkeyup = e => keys[e.key] = false;

        game.init();
        function animate() {
            requestAnimationFrame(animate);
            if (!joystick.active) {
                let kx = 0, ky = 0;
                if (keys['w'] || keys['ArrowUp']) ky = -1;
                if (keys['s'] || keys['ArrowDown']) ky = 1;
                if (keys['a'] || keys['ArrowLeft']) kx = -1;
                if (keys['d'] || keys['ArrowRight']) kx = 1;
                joystick.x = kx; joystick.y = ky;
            }
            game.update();
            renderer.render(scene, camera);
        }
        animate();
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>

</html>