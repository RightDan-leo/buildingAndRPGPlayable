<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Survival Tower Defense 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #1a1a2e;
            font-family: 'Arial', sans-serif;
        }

        canvas {
            display: block;
        }

        /* UI Overlay */
        #ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-radius: 10px;
            color: #fff;
            font-size: 16px;
            z-index: 10;
            border: 2px solid #444;
            backdrop-filter: blur(5px);
        }

        #ui-overlay div {
            margin: 5px 0;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            font-weight: bold;
            color: #fff;
        }

        .hp-value {
            color: #ff6b6b;
        }

        .wood-value {
            color: #8b5a2b;
        }

        .player-wood {
            color: #f0d084;
        }

        /* Turret Selection Modal */
        #turret-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        #turret-modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #2a2a4a 0%, #1a1a3a 100%);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            border: 3px solid #ffcc00;
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.3);
        }

        .modal-content h2 {
            color: #ffcc00;
            margin-bottom: 20px;
            font-size: 28px;
        }

        .modal-content p {
            color: #aaa;
            margin-bottom: 25px;
        }

        .turret-options {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .turret-btn {
            padding: 20px 30px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.2s, box-shadow 0.2s;
            min-width: 180px;
        }

        .turret-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(255, 255, 255, 0.3);
        }

        .turret-a {
            background: linear-gradient(135deg, #444 0%, #222 100%);
            color: #fff;
            border: 2px solid #666;
        }

        .turret-b {
            background: linear-gradient(135deg, #ff9500 0%, #cc6600 100%);
            color: #fff;
            border: 2px solid #ffaa00;
        }

        .turret-c {
            background: linear-gradient(135deg, #9900cc 0%, #660099 100%);
            color: #fff;
            border: 2px solid #aa00aa;
        }

        .worker-btn {
            background: linear-gradient(135deg, #00cccc 0%, #008888 100%);
            color: #fff;
            border: 2px solid #00ffff;
        }

        .turret-d {
            background: linear-gradient(135deg, #32cd32 0%, #006400 100%);
            color: #fff;
            border: 2px solid #00ff00;
        }

        .turret-btn small {
            display: block;
            margin-top: 8px;
            font-size: 12px;
            opacity: 0.8;
        }

        /* Game Over Screen */
        #game-over {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #game-over.active {
            display: flex;
        }

        #game-over h1 {
            color: #ff4444;
            font-size: 72px;
            margin-bottom: 20px;
            text-shadow: 0 0 30px #ff0000;
        }

        #game-over p {
            color: #aaa;
            font-size: 24px;
            margin-bottom: 30px;
        }

        #restart-btn {
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(135deg, #55cc55 0%, #338833 100%);
            color: #fff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #restart-btn:hover {
            transform: scale(1.05);
        }

        /* Controls hint */
        #controls-hint {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            color: #888;
            font-size: 12px;
            z-index: 10;
        }

        /* Minimap */
        #minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #444;
            border-radius: 10px;
            z-index: 10;
        }
    </style>
</head>

<body>
    <!-- UI Overlay -->
    <div id="ui-overlay">
        <div><span class="stat-label">Base HP:</span> <span id="base-hp" class="stat-value hp-value">200</span></div>
        <div><span class="stat-label">Base Wood:</span> <span id="base-wood" class="stat-value wood-value">0</span>
        </div>
        <div><span class="stat-label">Workers:</span> <span id="worker-count" class="stat-value"
                style="color:#00ffff">0</span></div>
        <div><span class="stat-label">Distance:</span> <span id="player-wood"
                class="stat-value player-wood">2000m</span></div>
    </div>

    <!-- Controls Hint -->
    <div id="controls-hint">
        <strong>Controls:</strong> WASD to move | Collect trees & kill enemies | Bring wood to base<br>
        <strong>Camera:</strong> Mouse to rotate | Scroll to zoom
    </div>

    <!-- Minimap -->
    <canvas id="minimap"></canvas>

    <!-- Objective Modal -->
    <div id="start-modal"
        style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:300; display:flex; flex-direction:column; justify-content:center; align-items:center; color:white; text-align:center;">
        <h1 style="color:#ffcc00; font-size:48px; text-shadow:0 0 20px orange;">æŠ¤é€è¥åœ°çªå›´</h1>
        <p style="font-size:24px; margin:20px 0; max-width:600px;">
            æˆ‘ä»¬çš„è¥åœ°æ­£åœ¨æ’¤ç¦»ï¼Œç›®æ ‡æ˜¯å‰æ–¹ 2000 ç±³å¤„çš„<span style="color:#00ffff">å¹¸å­˜è€…è¦å¡</span>ã€‚
            <br><br>
            âš”ï¸ <b>é˜²å¾¡:</b> å»ºé€ é˜²å¾¡å¡”æŠµå¾¡æ½®æ°´èˆ¬çš„æ€ªç‰©ã€‚<br>
            ğŸŒ² <b>èµ„æº:</b> åªæœ‰<b>é è¿‘æ ‘æœ¨</b>æ‰èƒ½é‡‡é›†æœ¨å¤´ï¼Œæœ¨å¤´æ˜¯é˜²å¾¡å¡”çš„<b>å¼¹è¯</b>ï¼<br>
            ğŸ <b>èƒœåˆ©:</b> ä¿æŠ¤æ ¸å¿ƒï¼Œæ´»ç€æŠµè¾¾ç»ˆç‚¹ï¼
        </p>
        <button onclick="document.getElementById('start-modal').style.display='none'; game.startParams();"
            style="padding:15px 40px; font-size:24px; background:#4CAF50; color:white; border:none; border-radius:10px; cursor:pointer; font-weight:bold;">å¼€å§‹çªå›´</button>
    </div>

    <!-- Turret Selection Modal -->
    <div id="turret-modal">
        <div class="modal-content">
            <h2>ğŸ—ï¸ å»ºé€ é˜²å¾¡å¡”</h2>
            <p>æ¶ˆè€— 50 æœ¨å¤´ã€‚é€‰æ‹©ç±»å‹:</p>
            <div class="turret-options">
                <button class="turret-btn turret-a" onclick="game.selectTurret('A')">
                    <strong>æ ‡å‡†å¡” (Standard)</strong>
                    <small>ä¸­å°„ç¨‹ / ç”¨äºå¹³è¡¡è¾“å‡º<br>æ¶ˆè€—: 1 æœ¨å¤´/å‘</small>
                </button>
                <button class="turret-btn turret-b" onclick="game.selectTurret('B')">
                    <strong>åŠ ç‰¹æ— (Rapid)</strong>
                    <small>çŸ­å°„ç¨‹ / æå¿«å°„é€Ÿ<br>æ¶ˆè€—: 1 æœ¨å¤´/å‘</small>
                </button>
                <button class="turret-btn turret-c" onclick="game.selectTurret('C')">
                    <strong>è¿«å‡»ç‚® (Mortar)</strong>
                    <small>è¿œå°„ç¨‹ / èŒƒå›´ä¼¤å®³<br>æ¶ˆè€—: 2 æœ¨å¤´/å‘</small>
                </button>
                <button class="turret-btn worker-btn" onclick="game.selectTurret('E')">
                    <strong>å·¥å…µç‚®å¡” (Worker Hub)</strong>
                    <small>å¬å”¤4ä¸ªå·¥å…µ<br>è‡ªåŠ¨é‡‡é›† & æ”»å‡» / æ¶ˆè€—: 50 æœ¨å¤´</small>
                </button>
                <button class="turret-btn turret-d" onclick="game.selectTurret('D')">
                    <strong>åŒ»ç–—å¡” (Repair)</strong>
                    <small>æ¢å¤åŸºåœ°ç”Ÿå‘½<br>5 HP/ç§’ / æ¶ˆè€—: 1 æœ¨å¤´/æ¬¡</small>
                </button>
            </div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over">
        <h1>GAME OVER</h1>
        <p>Your base was destroyed!</p>
        <p id="final-score"></p>
        <button id="restart-btn" onclick="game.restart()">Play Again</button>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ==========================================
        // SURVIVAL TOWER DEFENSE 3D GAME
        // ==========================================

        const game = {
            // Three.js objects
            scene: null,
            camera: null,
            renderer: null,
            clock: null,

            // Game state
            running: true,
            paused: false,
            gameOver: false,

            // World settings
            roadWidth: 20,
            worldWidth: 100,

            // Game objects
            base: null,
            player: null,
            enemies: [],
            trees: [],
            loots: [],
            projectiles: [],
            workers: [],

            // 3D meshes
            baseMesh: null,
            playerMesh: null,
            groundMesh: null,
            roadMesh: null,
            turretMeshes: [],

            // Camera control
            cameraAngle: 0,
            cameraHeight: 60,
            cameraDistance: 80,
            isDragging: false,
            lastMouseX: 0,

            // Timing
            gameTime: 0,
            enemySpawnTimer: 0,
            enemySpawnRate: 1,
            spawnUpgradeTimer: 0,

            // Stats
            enemiesKilled: 0,

            // Input
            keys: {},

            // Materials (shared)
            materials: {},

            // Destination
            destinationZ: -2000,

            // Audio System (Robust)
            audio: {
                ctx: null,
                masterGain: null,
                init: function () {
                    if (this.ctx) return;
                    try {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        this.ctx = new AudioContext();
                        this.masterGain = this.ctx.createGain();
                        this.masterGain.gain.value = 0.5; // Master Volume
                        this.masterGain.connect(this.ctx.destination);
                        console.log("Audio Initialized");
                    } catch (e) {
                        console.error("Audio Init Failed", e);
                    }
                },
                resume: function () {
                    if (this.ctx && this.ctx.state === 'suspended') {
                        this.ctx.resume().then(() => console.log("Audio Resumed"));
                    }
                },
                play: function (type) {
                    if (!this.ctx) this.init();
                    this.resume(); // Try to resume on every play

                    if (!this.ctx) return;

                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.connect(gain);
                    gain.connect(this.masterGain);

                    const now = this.ctx.currentTime;

                    if (type === 'shoot') {
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(600, now);
                        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                    } else if (type === 'hit') {
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(150, now);
                        osc.frequency.linearRampToValueAtTime(50, now + 0.1);
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.linearRampToValueAtTime(0.01, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                    } else if (type === 'chop') {
                        // Crunchier sound
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(120, now);
                        osc.frequency.exponentialRampToValueAtTime(60, now + 0.08);
                        gain.gain.setValueAtTime(0.5, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                        osc.start(now);
                        osc.stop(now + 0.08);
                    } else if (type === 'build') {
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(400, now);
                        osc.frequency.linearRampToValueAtTime(800, now + 0.2);
                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.2);
                        osc.start(now);
                        osc.stop(now + 0.2);
                    } else if (type === 'collect') {
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(800, now);
                        osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                    } else if (type === 'win') {
                        osc.type = 'triangle';
                        [0, 0.2, 0.4, 0.6].forEach((t, i) => {
                            const o = this.ctx.createOscillator();
                            const g = this.ctx.createGain();
                            o.connect(g);
                            g.connect(this.masterGain);
                            o.type = 'sine';
                            o.frequency.value = 440 * (i + 1) * 0.5; // Harmonic
                            g.gain.setValueAtTime(0.3, now + t);
                            g.gain.linearRampToValueAtTime(0, now + t + 0.3);
                            o.start(now + t);
                            o.stop(now + t + 0.3);
                        });
                    }
                }
            },

            // ==========================================
            // INITIALIZATION
            // ==========================================
            init() {
                this.setupThreeJS();
                this.setupMaterials();
                this.setupLighting();
                this.setupGround();
                this.setupGame();
                this.setupInput();

                // Audio Resume Safety
                document.addEventListener('click', () => {
                    if (this.audio.ctx && this.audio.ctx.state === 'suspended') {
                        this.audio.ctx.resume();
                    }
                }, { once: false });

                this.animate();
            },

            setupThreeJS() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87ceeb); // Sky blue
                this.scene.fog = new THREE.Fog(0x87ceeb, 100, 300);

                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                // Clock
                this.clock = new THREE.Clock();

                // Handle resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            },

            setupMaterials() {
                this.materials = {
                    grass: new THREE.MeshLambertMaterial({ color: 0x228b22 }),
                    road: new THREE.MeshLambertMaterial({ color: 0x444444 }),
                    roadLine: new THREE.MeshBasicMaterial({ color: 0xffffff }),
                    base: new THREE.MeshPhongMaterial({ color: 0x3366cc, shininess: 30 }),
                    baseTop: new THREE.MeshPhongMaterial({ color: 0x4477dd, shininess: 50 }),
                    player: new THREE.MeshPhongMaterial({ color: 0xf0f0f0, shininess: 60 }),
                    playerGlow: new THREE.MeshBasicMaterial({ color: 0xffcc00 }),
                    enemy: new THREE.MeshPhongMaterial({ color: 0xcc2222, shininess: 30 }),
                    tree: new THREE.MeshLambertMaterial({ color: 0x006400 }),
                    trunk: new THREE.MeshLambertMaterial({ color: 0x8b4513 }),
                    loot: new THREE.MeshPhongMaterial({ color: 0x8b5a2b, shininess: 40 }),
                    turretA: new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 50 }),
                    turretB: new THREE.MeshPhongMaterial({ color: 0xff8c00, shininess: 50 }),
                    turretC: new THREE.MeshPhongMaterial({ color: 0x8b008b, shininess: 50 }),
                    turretD: new THREE.MeshPhongMaterial({ color: 0x32cd32, shininess: 50 }),
                    projectile: new THREE.MeshBasicMaterial({ color: 0xffff00 }),
                    projectileGlow: new THREE.MeshBasicMaterial({ color: 0xff6600 })
                };
            },

            setupLighting() {
                // Ambient light
                const ambient = new THREE.AmbientLight(0x404050, 0.6);
                this.scene.add(ambient);

                // Main directional light (sun)
                const sun = new THREE.DirectionalLight(0xffffff, 1.0);
                sun.position.set(50, 100, 50);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048;
                sun.shadow.mapSize.height = 2048;
                sun.shadow.camera.near = 10;
                sun.shadow.camera.far = 300;
                sun.shadow.camera.left = -100;
                sun.shadow.camera.right = 100;
                sun.shadow.camera.top = 100;
                sun.shadow.camera.bottom = -100;
                this.scene.add(sun);
                this.sunLight = sun;

                // Hemisphere light for natural outdoor lighting
                const hemi = new THREE.HemisphereLight(0x87ceeb, 0x228b22, 0.4);
                this.scene.add(hemi);
            },

            setupGround() {
                // Create infinite scrolling ground segments
                this.groundSegments = [];
                this.roadSegments = [];

                const segmentLength = 100;
                const numSegments = 5;

                for (let i = 0; i < numSegments; i++) {
                    // Grass ground
                    const groundGeo = new THREE.PlaneGeometry(this.worldWidth, segmentLength);
                    const ground = new THREE.Mesh(groundGeo, this.materials.grass);
                    ground.rotation.x = -Math.PI / 2;
                    ground.position.z = -i * segmentLength + segmentLength;
                    ground.receiveShadow = true;
                    this.scene.add(ground);
                    this.groundSegments.push(ground);

                    // Road
                    const roadGeo = new THREE.PlaneGeometry(this.roadWidth, segmentLength);
                    const road = new THREE.Mesh(roadGeo, this.materials.road);
                    road.rotation.x = -Math.PI / 2;
                    road.position.y = 0.01;
                    road.position.z = -i * segmentLength + segmentLength;
                    road.receiveShadow = true;
                    this.scene.add(road);
                    this.roadSegments.push(road);

                    const lineGeo = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeo, this.materials.roadLine);
                    line.rotation.x = -Math.PI / 2;
                    line.position.y = 0.02;
                    line.position.z = -i * segmentLength + segmentLength;
                    this.scene.add(line);
                }

                // Create Destination Beacon at Z = -2000
                // Massive visual cue
                const beaconGroup = new THREE.Group();
                const beamGeo = new THREE.CylinderGeometry(5, 5, 200, 32, 1, true); // Tall beam
                const beamMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
                const beam = new THREE.Mesh(beamGeo, beamMat);
                beam.position.y = 100;

                // Core
                const coreGeo = new THREE.CylinderGeometry(2, 2, 220, 16);
                const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                const core = new THREE.Mesh(coreGeo, coreMat);
                core.position.y = 100;

                // Label (Mock with a Billboard box for now or just rely on the beam)
                // Assuming Beam is enough

                beaconGroup.add(beam);
                beaconGroup.add(core);
                beaconGroup.position.set(0, 0, -2000);

                this.scene.add(beaconGroup);
                this.destinationZ = -2000;
            },

            setupGame() {
                // Clear previous objects
                this.enemies.forEach(e => this.scene.remove(e.mesh));
                this.trees.forEach(t => this.scene.remove(t.mesh));
                this.loots.forEach(l => this.scene.remove(l.mesh));
                this.projectiles.forEach(p => this.scene.remove(p.mesh));
                this.turretMeshes.forEach(t => this.scene.remove(t));
                if (this.workers) {
                    this.workers.forEach(w => this.scene.remove(w.mesh));
                }

                if (this.baseMesh) this.scene.remove(this.baseMesh);
                if (this.playerMesh) this.scene.remove(this.playerMesh);

                this.enemies = [];
                this.trees = [];
                this.loots = [];
                this.projectiles = [];
                this.turretMeshes = [];
                this.workers = [];

                // Create base
                this.base = {
                    x: 0,
                    z: 0,
                    width: 15,
                    height: 15,
                    hp: 200,
                    maxHp: 200,
                    wood: 0,
                    speed: 2, // units per second
                    slots: Array(9).fill(null),
                    turrets: []
                };

                this.createBaseMesh();

                // Create player
                this.player = {
                    x: 0,
                    z: 20,
                    size: 3,
                    speed: 25,
                    wood: 0
                };

                this.createPlayerMesh();

                // Generate trees
                this.generateTrees();

                // Reset game state
                this.enemiesKilled = 0;
                this.gameTime = 0;
                this.enemySpawnTimer = 0;
                this.enemySpawnRate = 1;
                this.spawnUpgradeTimer = 0;
                this.gameOver = false;
                this.paused = false;
                this.running = true;

                document.getElementById('game-over').classList.remove('active');
                document.getElementById('turret-modal').classList.remove('active');

                this.createGuideArrow();
            },

            createBaseMesh() {
                // Base group
                this.baseMesh = new THREE.Group();

                // Main platform
                const baseGeo = new THREE.BoxGeometry(this.base.width, 3, this.base.height);
                const baseMesh = new THREE.Mesh(baseGeo, this.materials.base);
                baseMesh.position.y = 1.5;
                baseMesh.castShadow = true;
                baseMesh.receiveShadow = true;
                this.baseMesh.add(baseMesh);

                // Top platform
                const topGeo = new THREE.BoxGeometry(this.base.width - 2, 0.5, this.base.height - 2);
                const topMesh = new THREE.Mesh(topGeo, this.materials.baseTop);
                topMesh.position.y = 3.25;
                topMesh.castShadow = true;
                this.baseMesh.add(topMesh);

                // Corner pillars
                const pillarGeo = new THREE.CylinderGeometry(0.5, 0.6, 4, 8);
                const pillarMat = new THREE.MeshPhongMaterial({ color: 0x1a3d7a });

                const corners = [
                    [-this.base.width / 2 + 1, -this.base.height / 2 + 1],
                    [this.base.width / 2 - 1, -this.base.height / 2 + 1],
                    [-this.base.width / 2 + 1, this.base.height / 2 - 1],
                    [this.base.width / 2 - 1, this.base.height / 2 - 1]
                ];

                corners.forEach(([x, z]) => {
                    const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                    pillar.position.set(x, 2, z);
                    pillar.castShadow = true;
                    this.baseMesh.add(pillar);
                });

                // HP bar background
                const hpBgGeo = new THREE.BoxGeometry(this.base.width, 0.5, 1);
                const hpBgMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
                this.hpBarBg = new THREE.Mesh(hpBgGeo, hpBgMat);
                this.hpBarBg.position.set(0, 5, -this.base.height / 2 - 1);
                this.baseMesh.add(this.hpBarBg);

                // HP bar fill
                const hpFillGeo = new THREE.BoxGeometry(this.base.width - 0.2, 0.6, 0.9);
                const hpFillMat = new THREE.MeshBasicMaterial({ color: 0x44cc44 });
                this.hpBarFill = new THREE.Mesh(hpFillGeo, hpFillMat);
                this.hpBarFill.position.set(0, 5.05, -this.base.height / 2 - 1);
                this.baseMesh.add(this.hpBarFill);

                this.baseMesh.position.set(this.base.x, 0, this.base.z);
                this.scene.add(this.baseMesh);
            },

            createPlayerMesh() {
                this.playerMesh = new THREE.Group();

                // Body
                const bodyGeo = new THREE.BoxGeometry(this.player.size, this.player.size * 1.2, this.player.size);
                const body = new THREE.Mesh(bodyGeo, this.materials.player);
                body.position.y = this.player.size * 0.6;
                body.castShadow = true;
                this.playerMesh.add(body);

                // Head
                const headGeo = new THREE.SphereGeometry(this.player.size * 0.4, 16, 16);
                const head = new THREE.Mesh(headGeo, this.materials.player);
                head.position.y = this.player.size * 1.5;
                head.castShadow = true;
                this.playerMesh.add(head);

                // Glow ring
                const ringGeo = new THREE.RingGeometry(this.player.size * 0.8, this.player.size * 1.0, 32);
                const ring = new THREE.Mesh(ringGeo, this.materials.playerGlow);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 0.1;
                this.playerMesh.add(ring);

                // Eyes
                const eyeGeo = new THREE.SphereGeometry(0.2, 8, 8);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-0.5, this.player.size * 1.5, this.player.size * 0.3);
                this.playerMesh.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(0.5, this.player.size * 1.5, this.player.size * 0.3);
                this.playerMesh.add(rightEye);

                this.playerMesh.position.set(this.player.x, 0, this.player.z);
                this.scene.add(this.playerMesh);
            },

            generateTrees() {
                const roadHalf = this.roadWidth / 2;
                const worldHalf = this.worldWidth / 2;

                // Generate trees on both sides
                for (let i = 0; i < 100; i++) {
                    const side = Math.random() < 0.5 ? -1 : 1;
                    const x = side * (roadHalf + 5 + Math.random() * (worldHalf - roadHalf - 10));
                    const z = this.base.z - 50 + Math.random() * 200 - 100;

                    this.createTree(x, z);
                }
            },

            createTree(x, z) {
                const treeGroup = new THREE.Group();
                const scale = 0.8 + Math.random() * 0.4;

                // Trunk
                const trunkGeo = new THREE.CylinderGeometry(0.3 * scale, 0.4 * scale, 2 * scale, 8);
                const trunk = new THREE.Mesh(trunkGeo, this.materials.trunk);
                trunk.position.y = scale;
                trunk.castShadow = true;
                treeGroup.add(trunk);

                // Foliage layers
                const foliageGeo1 = new THREE.ConeGeometry(2 * scale, 3 * scale, 8);
                const foliage1 = new THREE.Mesh(foliageGeo1, this.materials.tree);
                foliage1.position.y = 3 * scale;
                foliage1.castShadow = true;
                treeGroup.add(foliage1);

                const foliageGeo2 = new THREE.ConeGeometry(1.5 * scale, 2.5 * scale, 8);
                const foliage2 = new THREE.Mesh(foliageGeo2, this.materials.tree);
                foliage2.position.y = 4.5 * scale;
                foliage2.castShadow = true;
                treeGroup.add(foliage2);

                const foliageGeo3 = new THREE.ConeGeometry(1 * scale, 2 * scale, 8);
                const foliage3 = new THREE.Mesh(foliageGeo3, this.materials.tree);
                foliage3.position.y = 5.5 * scale;
                foliage3.castShadow = true;
                treeGroup.add(foliage3);

                treeGroup.position.set(x, 0, z);
                this.scene.add(treeGroup);

                this.trees.push({
                    x: x,
                    z: z,
                    radius: 2 * scale,
                    mesh: treeGroup
                });
            },

            createEnemy(x, z) {
                const enemyGroup = new THREE.Group();

                // Body
                const bodyGeo = new THREE.BoxGeometry(2, 2.5, 2);
                const body = new THREE.Mesh(bodyGeo, this.materials.enemy);
                body.position.y = 1.25;
                body.castShadow = true;
                enemyGroup.add(body);

                // Eyes
                const eyeGeo = new THREE.SphereGeometry(0.2, 8, 8);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-0.4, 1.8, 1);
                enemyGroup.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(0.4, 1.8, 1);
                enemyGroup.add(rightEye);

                // Angry eyebrows
                const browGeo = new THREE.BoxGeometry(0.4, 0.1, 0.1);
                const browMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

                const leftBrow = new THREE.Mesh(browGeo, browMat);
                leftBrow.position.set(-0.4, 2.1, 1);
                leftBrow.rotation.z = 0.3;
                enemyGroup.add(leftBrow);

                const rightBrow = new THREE.Mesh(browGeo, browMat);
                rightBrow.position.set(0.4, 2.1, 1);
                rightBrow.rotation.z = -0.3;
                enemyGroup.add(rightBrow);

                enemyGroup.position.set(x, 0, z);
                this.scene.add(enemyGroup);

                return {
                    x: x,
                    z: z,
                    size: 2,
                    speed: 8 + Math.random() * 4,
                    hp: 2,
                    maxHp: 2,
                    mesh: enemyGroup
                };
            },

            createLoot(x, z) {
                const lootGroup = new THREE.Group();

                // Wood bundle
                const woodGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8);

                for (let i = 0; i < 3; i++) {
                    const log = new THREE.Mesh(woodGeo, this.materials.loot);
                    log.position.set((i - 1) * 0.4, 0.3, 0);
                    log.rotation.z = Math.PI / 2;
                    log.rotation.y = Math.random() * 0.3;
                    log.castShadow = true;
                    lootGroup.add(log);
                }

                // Glow effect
                const glowGeo = new THREE.RingGeometry(0.8, 1.2, 16);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0xf0d084,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.rotation.x = -Math.PI / 2;
                glow.position.y = 0.05;
                lootGroup.add(glow);

                lootGroup.position.set(x, 0, z);
                this.scene.add(lootGroup);

                const loot = {
                    x: x,
                    z: z,
                    wood: 10,
                    lifetime: 30,
                    mesh: lootGroup
                };

                this.loots.push(loot);
                return loot;
            },

            createTurret(type, offsetX, offsetZ, slot) {
                const turretGroup = new THREE.Group();

                let material, range, fireRate, damage, splash;

                switch (type) {
                    case 'A':
                        material = this.materials.turretA;
                        range = 25; // Slight range buff
                        fireRate = 4.5; // 4.5 shots/s
                        damage = 10;
                        splash = 0;
                        break;
                    case 'B':
                        material = this.materials.turretB;
                        range = 15; // Buff range slightly (was 12)
                        fireRate = 18; // 18 shots/s
                        damage = 1;
                        splash = 0;
                        break;
                    case 'C':
                        material = this.materials.turretC;
                        range = 40; // Buff range
                        fireRate = 1.8; // 1.8 shots/s
                        damage = 100;
                        splash = 10;
                        break;
                    case 'D':
                        material = this.materials.turretD;
                        range = 0; // Self
                        fireRate = 1; // 1 heal/sec
                        damage = -5; // Negative damage = Heal
                        splash = 0;
                        break;
                    case 'E':
                        material = new THREE.MeshPhongMaterial({ color: 0x00ffff }); // Cyan
                        range = 0;
                        fireRate = 0;
                        damage = 0;
                        splash = 0;
                        // Spawn workers immediately
                        for (let i = 0; i < 4; i++) {
                            this.createWorker();
                        }
                        break;
                }

                // Base
                const baseGeo = new THREE.CylinderGeometry(1.5, 1.8, 1, 16);
                const baseMesh = new THREE.Mesh(baseGeo, material);
                baseMesh.position.y = 3.5;
                baseMesh.castShadow = true;
                turretGroup.add(baseMesh);

                // Turret head
                const headGeo = new THREE.SphereGeometry(1, 16, 16);
                const head = new THREE.Mesh(headGeo, material);
                head.position.y = 4.5;
                head.castShadow = true;
                turretGroup.add(head);

                // Barrel
                const barrelGeo = new THREE.CylinderGeometry(0.2, 0.3, 2, 8);
                const barrelMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
                const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                barrel.position.set(0, 4.5, 1.5);
                barrel.rotation.x = Math.PI / 2;
                barrel.castShadow = true;
                turretGroup.add(barrel);

                turretGroup.userData = { barrel, type };
                this.baseMesh.add(turretGroup);
                turretGroup.position.set(offsetX, 0, offsetZ);

                this.turretMeshes.push(turretGroup);

                return {
                    type: type,
                    offsetX: offsetX,
                    offsetZ: offsetZ,
                    slot: slot,
                    range: range,
                    fireRate: fireRate,
                    damage: damage,
                    splash: splash,
                    cooldown: 0,
                    mesh: turretGroup
                };
            },

            createProjectile(startX, startY, startZ, targetX, targetZ, damage, splash, type) {
                const size = splash > 0 ? 0.5 : 0.3;
                const color = type === 'C' ? 0xff6600 : (type === 'B' ? 0xffaa00 : 0xffff00);

                const projGeo = new THREE.SphereGeometry(size, 8, 8);
                const projMat = new THREE.MeshBasicMaterial({ color: color });
                const projMesh = new THREE.Mesh(projGeo, projMat);

                // Glow effect
                const glowGeo = new THREE.SphereGeometry(size * 1.5, 8, 8);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                projMesh.add(glow);

                projMesh.position.set(startX, startY, startZ);
                this.scene.add(projMesh);

                return {
                    x: startX,
                    y: startY,
                    z: startZ,
                    targetX: targetX,
                    targetZ: targetZ,
                    speed: 40,
                    damage: damage,
                    splash: splash,
                    mesh: projMesh
                };
            },

            setupInput() {
                // Keyboard
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                });
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                // Mouse for camera control
                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        this.isDragging = true;
                        this.lastMouseX = e.clientX;
                    }
                });

                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const deltaX = e.clientX - this.lastMouseX;
                        this.cameraAngle += deltaX * 0.01;
                        this.lastMouseX = e.clientX;
                    }
                });

                // Scroll for zoom
                this.renderer.domElement.addEventListener('wheel', (e) => {
                    this.cameraDistance += e.deltaY * 0.05;
                    this.cameraDistance = Math.max(30, Math.min(150, this.cameraDistance));
                });
            },

            // ==========================================
            // GAME LOOP
            // ==========================================
            animate() {
                if (!this.running) return;
                requestAnimationFrame(() => this.animate());

                const dt = this.clock.getDelta();

                if (!this.paused && !this.gameOver) {
                    this.update(dt);
                }

                this.updateCamera();
                this.render();
                this.updateUI();
                this.updateMinimap();
            },

            // ==========================================
            // UPDATE LOGIC
            // ==========================================
            update(dt) {
                if (dt > 0.1) dt = 0.1;

                this.gameTime += dt;
                this.spawnUpgradeTimer += dt;

                // Increase spawn rate
                if (this.spawnUpgradeTimer >= 10) {
                    this.spawnUpgradeTimer = 0;
                    this.enemySpawnRate = Math.max(0.15, this.enemySpawnRate - 1 / 3);
                }

                this.updateBase(dt);
                this.updatePlayer(dt);
                this.updateEnemies(dt);
                this.updateTurrets(dt);
                this.updateProjectiles(dt);
                this.updateWorkers(dt);
                this.spawnEnemies(dt);
                this.cleanupObjects();
                this.checkCollisions();
                this.checkCollisions();
                this.checkTurretBuild();
                this.updateGuideArrow();

                // Regenerate trees
                if (this.trees.length < 50) {
                    this.addNewTrees();
                }
            },

            recruitWorker() {
                if (this.base.wood >= 50) {
                    this.base.wood -= 50;
                    this.createWorker();
                    this.audio.play('build');

                    // Close modal if open
                    document.getElementById('turret-modal').classList.remove('active');
                    this.paused = false;
                }
            },

            createWorker() {
                const workerGroup = new THREE.Group();
                // Little robot visuals
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), new THREE.MeshStandardMaterial({ color: 0x00ffff }));
                body.position.y = 0.75;
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                head.position.y = 1.8;
                workerGroup.add(body); workerGroup.add(head);

                workerGroup.position.copy(this.baseMesh.position);
                workerGroup.position.x += (Math.random() - 0.5) * 10;

                this.scene.add(workerGroup);

                this.workers.push({
                    mesh: workerGroup,
                    state: 'IDLE', // IDLE, MOVING, RETURNING
                    target: null,
                    speed: 20
                });
            },

            updateWorkers(dt) {
                this.workers.forEach(w => {
                    const wPos = w.mesh.position;

                    if (w.state === 'IDLE') {
                        // Find closest loot
                        let closest = null;
                        let minDist = 50; // Detection range

                        this.loots.forEach(l => {
                            const d = wPos.distanceTo(l.mesh.position);
                            if (d < minDist) {
                                minDist = d;
                                closest = l;
                            }
                        });

                        if (closest) {
                            w.target = closest;
                            w.state = 'MOVING';
                        } else {
                            // Follow base if no loot
                            const distToBase = wPos.distanceTo(this.baseMesh.position);
                            if (distToBase > 15) {
                                // Move to base
                                const dir = new THREE.Vector3().subVectors(this.baseMesh.position, wPos).normalize();
                                wPos.add(dir.multiplyScalar(w.speed * dt));
                                w.mesh.lookAt(this.baseMesh.position);
                            }
                        }
                    }
                    else if (w.state === 'MOVING') {
                        if (!w.target || !this.loots.includes(w.target)) {
                            w.state = 'IDLE';
                            w.target = null;
                            return;
                        }

                        const dir = new THREE.Vector3().subVectors(w.target.mesh.position, wPos).normalize();
                        wPos.add(dir.multiplyScalar(w.speed * dt));
                        w.mesh.lookAt(w.target.mesh.position);

                        if (wPos.distanceTo(w.target.mesh.position) < 2) {
                            // Collect
                            this.audio.play('collect'); // Collect sound
                            this.base.wood += w.target.wood;

                            // Remove loot
                            this.scene.remove(w.target.mesh);
                            const idx = this.loots.indexOf(w.target);
                            if (idx > -1) this.loots.splice(idx, 1);

                            w.target = null;
                            w.state = 'IDLE'; // Instant deposit for simplicity as per plan
                        }
                    }
                });
            },

            updateBase(dt) {
                // Move base forward (negative Z)
                this.base.z -= this.base.speed * dt;
                this.baseMesh.position.z = this.base.z;

                // Update ground segments for infinite scrolling
                this.groundSegments.forEach((segment, i) => {
                    if (segment.position.z > this.base.z + 150) {
                        segment.position.z -= this.groundSegments.length * 100;
                    }
                });

                this.roadSegments.forEach((segment, i) => {
                    if (segment.position.z > this.base.z + 150) {
                        segment.position.z -= this.roadSegments.length * 100;
                    }
                });

                // Update turret world positions
                this.base.turrets.forEach(turret => {
                    turret.x = this.base.x + turret.offsetX;
                    turret.z = this.base.z + turret.offsetZ;
                });

                // Update HP bar
                const hpPercent = Math.max(0, this.base.hp / this.base.maxHp);

                // Update scale from center
                this.hpBarFill.scale.x = hpPercent;

                // Adjust position to make it scale from left side
                const fullWidth = this.base.width - 0.2;
                this.hpBarFill.position.x = -fullWidth * (1 - hpPercent) / 2;

                if (hpPercent > 0.5) {
                    this.hpBarFill.material.color.setHex(0x44cc44);
                } else if (hpPercent > 0.25) {
                    this.hpBarFill.material.color.setHex(0xcccc44);
                } else {
                    this.hpBarFill.material.color.setHex(0xcc4444);
                }

                // Update sun position to follow
                this.sunLight.position.set(this.base.x + 50, 100, this.base.z + 50);
                this.sunLight.target.position.set(this.base.x, 0, this.base.z);
            },

            updatePlayer(dt) {
                // WASD movement relative to camera angle
                let moveX = 0, moveZ = 0;

                if (this.keys['w']) moveZ = -1;
                if (this.keys['s']) moveZ = 1;
                if (this.keys['a']) moveX = -1;
                if (this.keys['d']) moveX = 1;

                if (moveX !== 0 || moveZ !== 0) {
                    // Normalize
                    const len = Math.sqrt(moveX * moveX + moveZ * moveZ);
                    moveX /= len;
                    moveZ /= len;

                    // Apply camera rotation
                    const cos = Math.cos(this.cameraAngle);
                    const sin = Math.sin(this.cameraAngle);
                    const rotX = moveX * cos - moveZ * sin;
                    const rotZ = moveX * sin + moveZ * cos;

                    this.player.x += rotX * this.player.speed * dt;
                    this.player.z += rotZ * this.player.speed * dt;
                }

                // Keep player in bounds
                const halfWorld = this.worldWidth / 2 - 5;
                this.player.x = Math.max(-halfWorld, Math.min(halfWorld, this.player.x));

                // Keep player near base (can't go too far ahead or behind)
                const minZ = this.base.z - 60;
                const maxZ = this.base.z + 40;
                this.player.z = Math.max(minZ, Math.min(maxZ, this.player.z));

                // Update mesh
                this.playerMesh.position.set(this.player.x, 0, this.player.z);

                // Face movement direction
                if (moveX !== 0 || moveZ !== 0) {
                    const angle = Math.atan2(moveX, moveZ);
                    this.playerMesh.rotation.y = angle + this.cameraAngle;
                }
            },

            updateEnemies(dt) {
                this.enemies.forEach(enemy => {
                    const dx = this.base.x - enemy.x;
                    const dz = this.base.z - enemy.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist > 0) {
                        enemy.x += (dx / dist) * enemy.speed * dt;
                        enemy.z += (dz / dist) * enemy.speed * dt;

                        enemy.mesh.position.set(enemy.x, 0, enemy.z);

                        // Face base
                        enemy.mesh.rotation.y = Math.atan2(dx, dz);
                    }
                });
            },

            updateTurrets(dt) {
                this.base.turrets.forEach(turret => {
                    turret.cooldown -= dt;

                    if (turret.cooldown <= 0) {

                        // HEALER LOGIC
                        if (turret.type === 'D') {
                            if (this.base.hp < this.base.maxHp && this.base.wood >= 1) {
                                this.base.hp = Math.min(this.base.maxHp, this.base.hp + 5);
                                this.base.wood -= 1; // Cost 1 wood per heal
                                turret.cooldown = 1; // 1 sec cooldown

                                // Visual & Audio
                                this.audio.play('collect'); // Reuse nice chime sound

                                // Floating text effect (simple console for now or minimal visual)
                                // We can make the turret jump a bit
                                turret.mesh.position.y = 1;
                                setTimeout(() => { if (turret.mesh) turret.mesh.position.y = 0; }, 200);
                            }
                            return;
                        }

                        // ATTACK LOGIC (A, B, C)
                        let target = null;
                        let minDist = turret.range;

                        this.enemies.forEach(enemy => {
                            const dx = enemy.x - turret.x;
                            const dz = enemy.z - turret.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);

                            if (dist < minDist) {
                                minDist = dist;
                                target = enemy;
                            }
                        });

                        if (target) {
                            this.fireTurret(turret, target);
                            turret.cooldown = turret.fireRate;
                        }
                    }

                    // Rotate turret to face nearest enemy
                    let nearestEnemy = null;
                    let nearestDist = turret.range;

                    this.enemies.forEach(enemy => {
                        const dx = enemy.x - turret.x;
                        const dz = enemy.z - turret.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    });

                    if (nearestEnemy) {
                        const angle = Math.atan2(
                            nearestEnemy.x - turret.x,
                            nearestEnemy.z - turret.z
                        );
                        turret.mesh.rotation.y = angle;
                    }
                });
            },

            fireTurret(turret, target) {
                const proj = this.createProjectile(
                    turret.x,
                    4.5,
                    turret.z,
                    target.x,
                    target.z,
                    turret.damage,
                    turret.splash,
                    turret.type
                );

                this.projectiles.push(proj);
                this.audio.play('shoot');
            },

            updateProjectiles(dt) {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];

                    const dx = proj.targetX - proj.x;
                    const dz = proj.targetZ - proj.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < 2) {
                        // Hit
                        if (proj.splash > 0) {
                            // Create explosion effect
                            this.createExplosion(proj.x, proj.z, proj.splash);

                            // Splash damage
                            for (let j = this.enemies.length - 1; j >= 0; j--) {
                                const enemy = this.enemies[j];
                                const edx = enemy.x - proj.x;
                                const edz = enemy.z - proj.z;
                                const eDist = Math.sqrt(edx * edx + edz * edz);

                                if (eDist < proj.splash) {
                                    this.killEnemy(j);
                                }
                            }
                        } else {
                            // Single target
                            let hitEnemy = -1;
                            let minDist = 3;

                            this.enemies.forEach((enemy, idx) => {
                                const edx = enemy.x - proj.x;
                                const edz = enemy.z - proj.z;
                                const eDist = Math.sqrt(edx * edx + edz * edz);

                                if (eDist < minDist) {
                                    minDist = eDist;
                                    hitEnemy = idx;
                                }
                            });

                            if (hitEnemy >= 0) {
                                this.enemies[hitEnemy].hp -= proj.damage;
                                if (this.enemies[hitEnemy].hp <= 0) {
                                    this.killEnemy(hitEnemy);
                                }
                            }
                        }

                        this.scene.remove(proj.mesh);
                        this.projectiles.splice(i, 1);
                    } else {
                        // Move toward target
                        const moveSpeed = proj.speed * dt;
                        proj.x += (dx / dist) * moveSpeed;
                        proj.z += (dz / dist) * moveSpeed;
                        proj.y -= 0.5 * dt; // Gravity effect

                        proj.mesh.position.set(proj.x, Math.max(0.5, proj.y), proj.z);
                    }
                }
            },

            createExplosion(x, z, radius) {
                // Create particle explosion
                const particles = new THREE.Group();

                for (let i = 0; i < 20; i++) {
                    const geo = new THREE.SphereGeometry(0.3, 4, 4);
                    const mat = new THREE.MeshBasicMaterial({
                        color: Math.random() > 0.5 ? 0xff6600 : 0xffcc00
                    });
                    const particle = new THREE.Mesh(geo, mat);

                    particle.position.set(
                        (Math.random() - 0.5) * radius,
                        Math.random() * 3,
                        (Math.random() - 0.5) * radius
                    );

                    particles.add(particle);
                }

                particles.position.set(x, 0, z);
                this.scene.add(particles);

                // Remove after animation
                setTimeout(() => {
                    this.scene.remove(particles);
                }, 200);
            },

            spawnEnemies(dt) {
                this.enemySpawnTimer -= dt;

                if (this.enemySpawnTimer <= 0) {
                    this.enemySpawnTimer = this.enemySpawnRate;

                    // Spawn from edges
                    const edge = Math.floor(Math.random() * 4);
                    let x, z;

                    switch (edge) {
                        case 0: // Front
                            x = (Math.random() - 0.5) * this.worldWidth;
                            z = this.base.z - 80;
                            break;
                        case 1: // Back
                            x = (Math.random() - 0.5) * this.worldWidth;
                            z = this.base.z + 60;
                            break;
                        case 2: // Left
                            x = -this.worldWidth / 2 - 10;
                            z = this.base.z + (Math.random() - 0.5) * 100;
                            break;
                        case 3: // Right
                            x = this.worldWidth / 2 + 10;
                            z = this.base.z + (Math.random() - 0.5) * 100;
                            break;
                    }

                    this.enemies.push(this.createEnemy(x, z));
                }
            },

            killEnemy(index) {
                const enemy = this.enemies[index];

                // Create loot
                this.loots.push(this.createLoot(enemy.x, enemy.z));

                // Remove enemy
                this.scene.remove(enemy.mesh);
                this.enemies.splice(index, 1);
                this.enemiesKilled++;
            },

            checkCollisions() {
                // Player vs Trees
                for (let i = this.trees.length - 1; i >= 0; i--) {
                    // Auto-Collect Trees logic -> Change to Chop -> Spawn Loot
                    const tree = this.trees[i];
                    const dist = this.playerMesh.position.distanceTo(tree.mesh.position);
                    if (dist < 3) { // Close to tree
                        // Chop!
                        this.audio.play('chop');

                        // Spawn Loot instead of direct wood
                        this.createLoot(tree.x, tree.z);

                        this.scene.remove(tree.mesh);
                        this.trees.splice(i, 1);
                    }
                }

                // Player vs Enemies
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    const dx = this.player.x - enemy.x;
                    const dz = this.player.z - enemy.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < this.player.size + enemy.size) {
                        this.killEnemy(i);
                    }
                }

                // (Old Player vs Loots block removed)

                // Player vs Base (deposit wood)
                const baseDx = this.player.x - this.base.x;
                const baseDz = this.player.z - this.base.z;
                if (Math.abs(baseDx) < this.base.width / 2 + this.player.size &&
                    Math.abs(baseDz) < this.base.height / 2 + this.player.size) {
                    if (this.player.wood > 0) {
                        // First heal
                        const hpNeeded = this.base.maxHp - this.base.hp;
                        const woodForHeal = Math.min(this.player.wood, hpNeeded);
                        this.base.hp += woodForHeal;
                        this.player.wood -= woodForHeal;

                        // Remaining to storage
                        this.base.wood += this.player.wood;
                        this.player.wood = 0;
                    }
                }

                // Enemies vs Base
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    const dx = enemy.x - this.base.x;
                    const dz = enemy.z - this.base.z;

                    if (Math.abs(dx) < this.base.width / 2 + enemy.size &&
                        Math.abs(dz) < this.base.height / 2 + enemy.size) {
                        this.base.hp -= 5;
                        this.scene.remove(enemy.mesh);
                        this.enemies.splice(i, 1);

                        if (this.base.hp <= 0) {
                            this.triggerGameOver();
                        }
                    }
                }

                // Player vs Loots (RESTORED)
                for (let i = this.loots.length - 1; i >= 0; i--) {
                    const loot = this.loots[i];
                    const dx = this.player.x - loot.x;
                    const dz = this.player.z - loot.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < this.player.size + 2) {
                        // Collect
                        this.audio.play('collect');
                        this.base.wood += loot.wood;
                        this.scene.remove(loot.mesh);
                        this.loots.splice(i, 1);
                    }
                }

                // Update loot lifetime
                for (let i = this.loots.length - 1; i >= 0; i--) {
                    this.loots[i].lifetime -= 1 / 60;
                    if (this.loots[i].lifetime <= 0) {
                        this.scene.remove(this.loots[i].mesh);
                        this.loots.splice(i, 1);
                    }
                }
            },

            checkTurretBuild() {
                const availableSlot = this.base.slots.findIndex(s => s === null);

                if (this.base.wood >= 50 && availableSlot >= 0 && !this.paused) {
                    this.paused = true;
                    document.getElementById('turret-modal').classList.add('active');
                }
            },

            createGuideArrow() {
                // Create a pool of arrows for the path
                this.guidePath = [];
                const arrowCount = 8;

                // Create a flat chevron shape using ConeGeometry
                // Rotate geometry ONCE so -Z is forward (or whatever lookAt expects)
                const geometry = new THREE.ConeGeometry(1, 2, 4);
                geometry.rotateX(Math.PI / 2);

                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.6,
                    depthTest: false, // Always visible
                    side: THREE.DoubleSide
                });

                for (let i = 0; i < arrowCount; i++) {
                    const arrow = new THREE.Mesh(geometry, material);
                    arrow.position.y = 0.5;
                    arrow.visible = false;
                    arrow.scale.set(1, 1, 0.5); // Flatten
                    this.scene.add(arrow);
                    this.guidePath.push(arrow);
                }
            },

            updateGuideArrow() {
                if (!this.guidePath || !this.playerMesh) return;

                const canAfford = this.base.wood >= 50;
                const hasEmptySlot = this.base.slots.some(s => s === null);
                const shouldShow = canAfford && hasEmptySlot;

                if (shouldShow) {
                    const startPos = this.playerMesh.position.clone();
                    const endPos = this.baseMesh.position.clone();

                    const lookTarget = endPos.clone();
                    lookTarget.y = 0.5;

                    this.guidePath.forEach((arrow, index) => {
                        arrow.visible = true;

                        // Distribute
                        const t = (index + 1) / (this.guidePath.length + 1);
                        arrow.position.lerpVectors(startPos, endPos, t);
                        arrow.position.y = 0.5;

                        arrow.lookAt(lookTarget);

                        // Animation: Pulse
                        const time = Date.now() * 0.005;
                        arrow.material.opacity = 0.5 + Math.sin(time - index * 0.5) * 0.3;
                    });
                } else {
                    this.guidePath.forEach(arrow => arrow.visible = false);
                }
            },

            selectTurret(type) {
                const availableSlot = this.base.slots.findIndex(s => s === null);
                if (availableSlot < 0) return;

                // Calculate position in 3x3 grid
                const row = Math.floor(availableSlot / 3);
                const col = availableSlot % 3;
                const cellSize = this.base.width / 3;
                const offsetX = (col - 1) * cellSize;
                const offsetZ = (row - 1) * cellSize;

                const turret = this.createTurret(type, offsetX, offsetZ, availableSlot);

                this.base.slots[availableSlot] = type;
                this.base.turrets.push(turret);
                this.base.wood -= 50;

                document.getElementById('turret-modal').classList.remove('active');
                this.paused = false;
            },

            addNewTrees() {
                const roadHalf = this.roadWidth / 2;
                const worldHalf = this.worldWidth / 2;

                for (let i = 0; i < 10; i++) {
                    const side = Math.random() < 0.5 ? -1 : 1;
                    const x = side * (roadHalf + 5 + Math.random() * (worldHalf - roadHalf - 10));
                    const z = this.base.z - 100 - Math.random() * 50;

                    this.createTree(x, z);
                }
            },

            cleanupObjects() {
                // Remove objects too far behind
                const minZ = this.base.z + 100;

                for (let i = this.trees.length - 1; i >= 0; i--) {
                    if (this.trees[i].z > minZ) {
                        this.scene.remove(this.trees[i].mesh);
                        this.trees.splice(i, 1);
                    }
                }

                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    if (this.enemies[i].z > minZ) {
                        this.scene.remove(this.enemies[i].mesh);
                        this.enemies.splice(i, 1);
                    }
                }

                for (let i = this.loots.length - 1; i >= 0; i--) {
                    if (this.loots[i].z > minZ) {
                        this.scene.remove(this.loots[i].mesh);
                        this.loots.splice(i, 1);
                    }
                }
            },

            triggerGameOver() {
                this.gameOver = true;
                document.getElementById('final-score').textContent =
                    `Enemies killed: ${this.enemiesKilled} | Turrets built: ${this.base.turrets.length}`;
                document.getElementById('game-over').classList.add('active');
            },

            restart() {
                this.setupGame();
            },

            // ==========================================
            // CAMERA
            // ==========================================
            updateCamera() {
                // Orbit camera around base
                const targetX = this.base.x;
                const targetZ = this.base.z;

                const camX = targetX + Math.sin(this.cameraAngle) * this.cameraDistance;
                const camZ = targetZ + Math.cos(this.cameraAngle) * this.cameraDistance;
                const camY = this.cameraHeight;

                this.camera.position.set(camX, camY, camZ);
                this.camera.lookAt(targetX, 0, targetZ);
            },

            // ==========================================
            // RENDERING
            // ==========================================
            render() {
                this.renderer.render(this.scene, this.camera);
            },

            // ==========================================
            // UI
            // ==========================================
            updateUI() {
                document.getElementById('base-hp').innerText = Math.ceil(this.base.hp);
                document.getElementById('base-wood').innerText = this.base.wood; // Using Base Wood as Ammo
                document.getElementById('worker-count').innerText = this.workers.length;
                document.getElementById('player-wood').innerText = Math.abs(Math.floor((this.base.z - this.destinationZ) / 10)) + "m"; // Reuse for Distance
                const spawnPerSecond = (1 / this.enemySpawnRate).toFixed(1);
                document.getElementById('spawn-rate').textContent = spawnPerSecond + '/s';
            },

            updateMinimap() {
                const canvas = document.getElementById('minimap');
                const ctx = canvas.getContext('2d');
                const size = 150;
                canvas.width = size;
                canvas.height = size;

                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, size, size);

                // Scale factor
                const scale = size / 150;
                const centerX = size / 2;
                const centerY = size / 2;

                // Draw road
                ctx.fillStyle = '#555';
                ctx.fillRect(centerX - 10, 0, 20, size);

                // Draw base (center)
                ctx.fillStyle = '#3366cc';
                ctx.fillRect(centerX - 8, centerY - 8, 16, 16);

                // Draw turrets on base
                this.base.turrets.forEach(turret => {
                    ctx.fillStyle = turret.type === 'A' ? '#333' :
                        (turret.type === 'B' ? '#ff8c00' : '#8b008b');
                    const tx = centerX + turret.offsetX * scale * 0.5;
                    const tz = centerY + turret.offsetZ * scale * 0.5;
                    ctx.beginPath();
                    ctx.arc(tx, tz, 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw trees
                ctx.fillStyle = '#006400';
                this.trees.forEach(tree => {
                    const tx = centerX + (tree.x - this.base.x) * scale;
                    const tz = centerY + (tree.z - this.base.z) * scale;
                    if (tx >= 0 && tx <= size && tz >= 0 && tz <= size) {
                        ctx.beginPath();
                        ctx.arc(tx, tz, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // Draw enemies
                ctx.fillStyle = '#cc2222';
                this.enemies.forEach(enemy => {
                    const ex = centerX + (enemy.x - this.base.x) * scale;
                    const ez = centerY + (enemy.z - this.base.z) * scale;
                    if (ex >= 0 && ex <= size && ez >= 0 && ez <= size) {
                        ctx.fillRect(ex - 2, ez - 2, 4, 4);
                    }
                });

                // Draw loots
                ctx.fillStyle = '#f0d084';
                this.loots.forEach(loot => {
                    const lx = centerX + (loot.x - this.base.x) * scale;
                    const lz = centerY + (loot.z - this.base.z) * scale;
                    if (lx >= 0 && lx <= size && lz >= 0 && lz <= size) {
                        ctx.beginPath();
                        ctx.arc(lx, lz, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // Draw player
                ctx.fillStyle = '#ffcc00';
                const px = centerX + (this.player.x - this.base.x) * scale;
                const pz = centerY + (this.player.z - this.base.z) * scale;
                ctx.beginPath();
                ctx.arc(px, pz, 4, 0, Math.PI * 2);
                ctx.fill();

                // Border
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, size, size);
            }
        };

        // Start the game
        window.onload = () => game.init();
    </script>
</body>

</html>