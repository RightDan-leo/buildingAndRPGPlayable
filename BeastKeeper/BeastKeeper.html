<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å·¨å…½æ”¶å®¹æ‰€ - BeastKeeper</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            touch-action: none;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: #1a1a2e;
        }

        #gameCanvas {
            display: block;
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .resource-bar {
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 15px;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .resource-bar .icon {
            font-size: 20px;
        }

        .resource-bar .value {
            font-weight: bold;
            color: #ffd700;
        }

        /* Joystick */
        #joystickZone {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            z-index: 200;
        }

        /* Tutorial Overlay */
        #tutorialOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 500;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        #tutorialOverlay h1 {
            font-size: 36px;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px #000;
        }

        #tutorialOverlay .hand {
            font-size: 80px;
            animation: handMove 1.5s infinite;
        }

        @keyframes handMove {

            0%,
            100% {
                transform: translate(0, 0);
            }

            50% {
                transform: translate(30px, 30px);
            }
        }

        #tutorialOverlay p {
            font-size: 20px;
            margin-top: 20px;
            opacity: 0.8;
        }

        /* Prompts */
        #promptBox {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 60, 0.9));
            padding: 15px 30px;
            border-radius: 15px;
            border: 2px solid #4CAF50;
            color: white;
            font-size: 20px;
            z-index: 300;
            text-align: center;
            display: none;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 10px #4CAF50;
            }

            50% {
                box-shadow: 0 0 25px #4CAF50;
            }
        }

        /* Beast Panel */
        #beastPanel {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .beast-card {
            background: rgba(0, 0, 0, 0.85);
            padding: 10px 15px;
            border-radius: 12px;
            border: 2px solid #666;
            color: white;
            min-width: 160px;
        }

        .beast-card.active {
            border-color: #4CAF50;
        }

        .beast-card .name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .beast-card .stage {
            font-size: 12px;
            color: #aaa;
        }

        .beast-card .progress-bar {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }

        .beast-card .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s;
        }

        .beast-card .feed-btn {
            margin-top: 8px;
            padding: 6px 12px;
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            border: none;
            border-radius: 15px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .beast-card .feed-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.6);
        }

        .beast-card .feed-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        /* Victory Screen */
        #victoryScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            z-index: 1000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        #victoryScreen h1 {
            font-size: 48px;
            color: #ffd700;
            text-shadow: 3px 3px 6px #000;
            margin-bottom: 20px;
        }

        #victoryScreen p {
            font-size: 20px;
            margin-bottom: 40px;
            opacity: 0.9;
        }

        #victoryScreen .btn {
            padding: 15px 40px;
            font-size: 22px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s;
        }

        #victoryScreen .btn:hover {
            transform: scale(1.05);
        }

        #victoryScreen .btn-download {
            background: linear-gradient(135deg, #f39c12, #e74c3c);
            color: white;
        }

        #victoryScreen .btn-restart {
            background: #555;
            color: white;
        }

        /* Controls hint */
        #controlsHint {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border-radius: 20px;
            color: #aaa;
            font-size: 14px;
            z-index: 50;
        }

        /* Boss Health Bar */
        #bossHealthBar {
            display: none;
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            max-width: 80%;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #ff0000;
            border-radius: 10px;
            padding: 10px 15px;
            z-index: 350;
        }

        #bossHealthBar .boss-name {
            color: #ff4444;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 8px;
            text-shadow: 0 0 10px #ff0000;
        }

        #bossHealthBar .hp-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
        }

        #bossHealthBar .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4444);
            transition: width 0.3s;
            box-shadow: 0 0 10px #ff0000;
        }

        #bossHealthBar .hp-text {
            color: white;
            font-size: 14px;
            text-align: center;
            margin-top: 5px;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <div class="resource-bar">
            <span class="icon">ğŸ¥©</span>
            <span>è‚‰å—:</span>
            <span class="value" id="meatCount">15</span>
        </div>
        <div class="resource-bar">
            <span class="icon">ğŸª™</span>
            <span>é‡‘å¸:</span>
            <span class="value" id="coinCount">0</span>
        </div>
    </div>

    <!-- Beast Panel -->
    <div id="beastPanel"></div>

    <!-- Prompt Box -->
    <div id="promptBox"></div>

    <!-- Joystick Zone -->
    <!-- Tutorial joystick (right bottom, static) -->
    <div id="joystickZone"></div>

    <!-- Tutorial Overlay -->
    <div id="tutorialOverlay">
        <h1>ğŸ‰ å·¨å…½æ”¶å®¹æ‰€ ğŸ‰</h1>
        <div class="hand">ğŸ‘†</div>
        <p>æ‹–åŠ¨æ‘‡æ†æˆ–ä½¿ç”¨ WASD ç§»åŠ¨</p>
        <p style="opacity:0.5; font-size:14px;">ç‚¹å‡»ä»»æ„ä½ç½®å¼€å§‹</p>
    </div>

    <!-- Victory Screen -->
    <div id="victoryScreen">
        <h1>ğŸ† èƒœåˆ©ï¼ğŸ†</h1>
        <p>æ­å–œä½ æˆåŠŸç»è¥äº†å·¨å…½æ”¶å®¹æ‰€ï¼</p>
        <button class="btn btn-download" onclick="window.open('https://example.com/download')">
            ğŸ“² ç«‹å³ä¸‹è½½å®Œæ•´ç‰ˆ
        </button>
        <button class="btn btn-restart" onclick="location.reload()">
            ğŸ”„ é‡æ–°å¼€å§‹
        </button>
    </div>

    <!-- Boss Health Bar -->
    <div id="bossHealthBar">
        <div class="boss-name">â˜ ï¸ æœ€ç»ˆBOSS - é»‘æš—å·¨å…½ â˜ ï¸</div>
        <div class="hp-bar">
            <div class="hp-fill" id="bossHpFill" style="width: 100%;"></div>
        </div>
        <div class="hp-text" id="bossHpText">1000 / 1000</div>
    </div>

    <!-- Skill Selection Modal -->
    <div id="skillModal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:600; justify-content:center; align-items:center;">
        <div
            style="background:linear-gradient(135deg, #2a1a3a, #1a2a4a); border:3px solid #ffd700; border-radius:15px; padding:30px; max-width:500px; text-align:center;">
            <h2 id="skillModalTitle" style="color:#ffd700; margin-bottom:20px;">ğŸŒŸ é€‰æ‹©æŠ€èƒ½ ğŸŒŸ</h2>
            <div id="skillChoices" style="display:flex; gap:20px; justify-content:center;">
                <!-- Skill buttons will be injected here -->
            </div>
        </div>
    </div>

    <!-- Controls Hint -->
    <div id="controlsHint">WASD æˆ– æ‹–åŠ¨æ‘‡æ†ç§»åŠ¨</div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

    <script>
        // ==================== GAME CONFIG ====================
        const CONFIG = {
            // Resources - enough for first feed
            startingMeat: 15,
            startingCoins: 0,

            // Beast feeding - one feed = full progress
            feedCost: 10,
            feedProgressPerFeed: 100, // One feed fills bar completely

            // Buildings
            meatFactoryCost: 50,
            workerHutCost: 80,
            upgradeMeatFactoryCost: 100,
            meatProductionRate: 2, // per second
            meatProductionRateUpgraded: 5,

            // Combat - increased ranges and speeds
            enemySpawnInterval: 3, // seconds - reduced spawning
            beastAttackRange: 25, // INCREASED for ranged attacks
            beastAttackDamage: { baby: 0, healthy: 15, evolved: 60 },
            beastMoveSpeed: 12, // Beasts move towards enemies
            enemySpeed: 8, // Faster enemies
            bossHp: 2000, // Quadrupled for longer fight
            bossSpawnDelay: 5,

            // Player - faster movement
            playerSpeed: 25,
            collectRange: 3,

            // Fence defense
            fenceMaxHp: 100,
            fenceRegenRate: 1, // HP per second when not attacked
            fenceEnemyDamage: 5, // damage per enemy attack
            fenceBoundary: 25 // fence at Â±25
        };

        // ==================== SOUND MANAGER ====================
        const SoundManager = {
            ctx: null,

            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            playTone(freq, type, duration, volume = 0.15) {
                if (!this.ctx) return;
                try {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();

                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);

                    gain.gain.setValueAtTime(volume, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

                    osc.connect(gain);
                    gain.connect(this.ctx.destination);

                    osc.start();
                    osc.stop(this.ctx.currentTime + duration);
                } catch (e) { }
            },

            // Capture beast - hopeful rising sound
            playCapture() {
                this.playTone(300, 'sine', 0.1, 0.12);
                setTimeout(() => this.playTone(400, 'sine', 0.1, 0.12), 100);
                setTimeout(() => this.playTone(600, 'sine', 0.2, 0.15), 200);
            },

            // Feed beast - soft nurturing sound
            playFeed() {
                this.playTone(500, 'sine', 0.15, 0.1);
                setTimeout(() => this.playTone(600, 'sine', 0.15, 0.1), 80);
            },

            // Evolution - epic ascending sweep
            playEvolve() {
                this.playTone(200, 'sawtooth', 0.15, 0.08);
                setTimeout(() => this.playTone(300, 'sawtooth', 0.15, 0.1), 100);
                setTimeout(() => this.playTone(400, 'triangle', 0.15, 0.12), 200);
                setTimeout(() => this.playTone(500, 'triangle', 0.15, 0.14), 300);
                setTimeout(() => this.playTone(700, 'sine', 0.3, 0.18), 400);
            },

            // Attack - sharp shot sound
            playAttack() {
                this.playTone(800, 'square', 0.05, 0.08);
                this.playTone(400, 'sawtooth', 0.08, 0.06);
            },

            // Hit enemy - impact thud
            playHit() {
                this.playTone(150, 'square', 0.1, 0.1);
                this.playTone(80, 'sawtooth', 0.12, 0.08);
            },

            // AOE explosion
            playAoe() {
                this.playTone(100, 'sawtooth', 0.2, 0.12);
                this.playTone(60, 'square', 0.25, 0.1);
                setTimeout(() => this.playTone(150, 'triangle', 0.15, 0.08), 100);
            },

            // Chain lightning
            playChain() {
                this.playTone(1200, 'sawtooth', 0.05, 0.08);
                setTimeout(() => this.playTone(1000, 'sawtooth', 0.05, 0.06), 50);
                setTimeout(() => this.playTone(800, 'sawtooth', 0.05, 0.04), 100);
            },

            // Boss spawn - ominous warning
            playBossSpawn() {
                this.playTone(80, 'sawtooth', 0.4, 0.15);
                setTimeout(() => this.playTone(60, 'sawtooth', 0.4, 0.18), 200);
                setTimeout(() => this.playTone(40, 'square', 0.5, 0.2), 400);
            },

            // Boss defeated - victory fanfare
            playVictory() {
                this.playTone(400, 'sine', 0.2, 0.12);
                setTimeout(() => this.playTone(500, 'sine', 0.2, 0.12), 150);
                setTimeout(() => this.playTone(600, 'sine', 0.2, 0.14), 300);
                setTimeout(() => this.playTone(800, 'triangle', 0.4, 0.18), 450);
            },

            // Skill selection - magical chime
            playSkillSelect() {
                this.playTone(700, 'sine', 0.1, 0.1);
                setTimeout(() => this.playTone(900, 'sine', 0.15, 0.12), 80);
                setTimeout(() => this.playTone(1100, 'triangle', 0.2, 0.1), 160);
            },

            // Loot collect - coin sound
            playCollect() {
                this.playTone(1000, 'sine', 0.08, 0.1);
                setTimeout(() => this.playTone(1200, 'sine', 0.08, 0.08), 50);
            },

            // Building complete
            playBuild() {
                this.playTone(300, 'square', 0.1, 0.1);
                setTimeout(() => this.playTone(400, 'square', 0.1, 0.1), 100);
                setTimeout(() => this.playTone(500, 'triangle', 0.2, 0.12), 200);
            }
        };


        // ==================== BEAST SKILLS ====================
        const BEAST_SKILLS = {
            hydra: {
                // Upgrade level 1 (healthy -> level1)
                1: [
                    { id: 'venom_boost', name: 'æ¯’æ¶²å¢å¼º', desc: '+30%ä¼¤å®³', emoji: 'ğŸ§ª', effect: { damageMultiplier: 1.3 } },
                    { id: 'multi_head', name: 'å¤šå¤´æ”»å‡»', desc: 'æ”»å‡»2ä¸ªç›®æ ‡', emoji: 'ğŸ²', effect: { multiTarget: 2 } }
                ],
                // Upgrade level 2 (level1 -> level2)
                2: [
                    { id: 'poison_spray', name: 'å‰§æ¯’å–·å°„', desc: 'èŒƒå›´ä¼¤å®³', emoji: 'ğŸ’€', effect: { aoe: true, aoeRadius: 5 } },
                    { id: 'life_steal', name: 'ç”Ÿå‘½æ±²å–', desc: 'ä¼¤å®³å›è¡€10%', emoji: 'ğŸ’š', effect: { lifeSteal: 0.1 } }
                ],
                // Upgrade level 3 (level2 -> level3)
                3: [
                    { id: 'poison_cloud', name: 'æ¯’æ°”äº‘', desc: 'æŒç»­ä¼¤å®³åŒºåŸŸ', emoji: 'â˜ï¸', effect: { dot: true, dotDamage: 5 } },
                    { id: 'regen', name: 'å¿«é€Ÿå†ç”Ÿ', desc: 'æ¯ç§’å›å¤HP', emoji: 'ğŸ’—', effect: { hpRegen: 5 } }
                ],
                // Ultimate (level3 -> evolved)
                ultimate: [
                    { id: 'nine_heads', name: 'ä¹å¤´é½å°„', desc: 'æ”»å‡»9ç›®æ ‡', emoji: 'ğŸ”¥', effect: { multiTarget: 9, damageMultiplier: 1.5 }, isUltimate: true },
                    { id: 'poison_breath', name: 'æ¯’é¾™åæ¯', desc: 'å¤§èŒƒå›´æ¯ç­', emoji: 'â˜ ï¸', effect: { aoe: true, aoeRadius: 15, damageMultiplier: 2 }, isUltimate: true }
                ]
            },
            thunderbird: {
                1: [
                    { id: 'thunder_boost', name: 'é›·å‡»å¼ºåŒ–', desc: '+30%ä¼¤å®³', emoji: 'âš¡', effect: { damageMultiplier: 1.3 } },
                    { id: 'swift_wind', name: 'ç–¾é£', desc: '+50%æ”»é€Ÿ', emoji: 'ğŸ’¨', effect: { attackSpeedMultiplier: 1.5 } }
                ],
                2: [
                    { id: 'chain_lightning', name: 'è¿é”é—ªç”µ', desc: 'å¼¹å°„3æ•Œäºº', emoji: 'ğŸ”—', effect: { chainTarget: 3 } },
                    { id: 'storm_shield', name: 'é£æš´æŠ¤ç›¾', desc: 'å‡ä¼¤30%', emoji: 'ğŸ›¡ï¸', effect: { damageReduction: 0.3 } }
                ],
                3: [
                    { id: 'thunder_cloud', name: 'é›·äº‘å¬å”¤', desc: 'èŒƒå›´é›·å‡»', emoji: 'ğŸŒ©ï¸', effect: { aoe: true, aoeRadius: 8 } },
                    { id: 'dash_attack', name: 'å†²åˆºæ”»å‡»', desc: 'å†²å‘æ•Œäºº', emoji: 'ğŸƒ', effect: { dash: true, dashSpeed: 30 } }
                ],
                ultimate: [
                    { id: 'divine_thunder', name: 'å¤©é›·é™ä¸´', desc: 'å…¨å±é›·å‡»', emoji: 'â›ˆï¸', effect: { globalAoe: true, damageMultiplier: 3 }, isUltimate: true },
                    { id: 'phoenix_form', name: 'å‡¤å‡°å½¢æ€', desc: 'æ— æ•Œ+çˆ†å‘', emoji: 'ğŸ”¶', effect: { invincible: 3, burstDamage: 5 }, isUltimate: true }
                ]
            }
        };

        // ==================== GAME STATE ====================
        const game = {
            started: false,
            step: 1,
            meat: CONFIG.startingMeat,
            coins: CONFIG.startingCoins,

            beasts: [],
            buildings: [],
            enemies: [],
            loot: [],
            workers: [],
            projectiles: [], // Beast ranged attacks
            buildingLabels: [], // 3D building info labels

            // Flags
            hydraSpawned: false,
            thunderbirdSpawned: false,
            meatFactoryBuilt: false,
            workerHutBuilt: false,
            meatFactoryUpgraded: false,
            bossSpawned: false,
            bossDefeated: false,

            // Timer
            lastTime: 0,
            meatProductionTimer: 0,
            enemySpawnTimer: 0,

            // Fence defense
            fenceHealth: 100,
            fenceUnderAttack: false,
            fenceRegenTimer: 0
        };

        // ==================== THREE.JS SETUP ====================
        let scene, camera, renderer;
        let player, playerMesh;
        let groundMesh;
        const clock = new THREE.Clock();

        // Input
        const keys = { w: false, a: false, s: false, d: false };
        let joystickVector = { x: 0, y: 0 };
        let tutorialJoystick = null; // Static joystick for tutorial
        let dynamicJoystick = null;  // Dynamic joystick for gameplay

        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x228B22);
            scene.fog = new THREE.Fog(0x228B22, 50, 150);

            // Camera (Orthographic for top-down)
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 18;
            camera = new THREE.OrthographicCamera(
                -viewSize * aspect, viewSize * aspect,
                viewSize, -viewSize,
                1, 1000
            );
            camera.position.set(0, 30, 20);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(30, 50, 30);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(200, 200);
            const groundMat = new THREE.MeshPhongMaterial({
                color: 0x3d8b40,
                side: THREE.DoubleSide
            });
            groundMesh = new THREE.Mesh(groundGeo, groundMat);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Sanctuary fence
            createSanctuaryArea();

            // Player
            createPlayer();

            // Spawn initial Hydra
            spawnInjuredHydra();

            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }

        function createSanctuaryArea() {
            // Fence posts around sanctuary - CIRCULAR
            const fenceMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const postGeo = new THREE.CylinderGeometry(0.3, 0.3, 3, 8);

            // Place fence posts in a circle (radius = fenceBoundary)
            const radius = CONFIG.fenceBoundary;
            const numPosts = 24; // Posts around the circle
            for (let i = 0; i < numPosts; i++) {
                const angle = (i / numPosts) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const post = new THREE.Mesh(postGeo, fenceMat);
                post.position.set(x, 1.5, z);
                post.castShadow = true;
                scene.add(post);
            }

            // Beast pen area (darker grass)
            const penGeo = new THREE.PlaneGeometry(20, 15);
            const penMat = new THREE.MeshPhongMaterial({ color: 0x2d6a2e });
            const penMesh = new THREE.Mesh(penGeo, penMat);
            penMesh.rotation.x = -Math.PI / 2;
            penMesh.position.set(-10, 0.01, 10);
            scene.add(penMesh);

            // Building area markers
            createBuildingSpot(15, 10, 'meat_factory');
            createBuildingSpot(15, -5, 'worker_hut');

            // Create upgrade label (initially hidden, shown by updateBuildingLabels at step 9)
            showUpgradeLabel(15, 10);
        }

        function createBuildingSpot(x, z, type) {
            const spotGeo = new THREE.PlaneGeometry(8, 8);
            const spotMat = new THREE.MeshPhongMaterial({
                color: 0x555555,
                transparent: true,
                opacity: 0.5
            });
            const spot = new THREE.Mesh(spotGeo, spotMat);
            spot.rotation.x = -Math.PI / 2;
            spot.position.set(x, 0.02, z);
            spot.userData = { type: type, isSpot: true };
            scene.add(spot);

            // Create building info label
            const labelGroup = new THREE.Group();

            // Info text based on type
            let labelInfo;
            if (type === 'meat_factory') {
                labelInfo = {
                    name: 'ğŸ­ é€ è‚‰å‚',
                    desc: 'è‡ªåŠ¨äº§è‚‰',
                    cost: CONFIG.meatFactoryCost
                };
            } else if (type === 'worker_hut') {
                labelInfo = {
                    name: 'ğŸ  å·¥äººå°å±‹',
                    desc: '4å·¥äººè‡ªåŠ¨æ”¶é›†',
                    cost: CONFIG.workerHutCost
                };
            }

            // Create floating billboard using canvas texture
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.roundRect(0, 0, 256, 128, 10);
            ctx.fill();
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(labelInfo.name, 128, 35);

            ctx.font = '20px Arial';
            ctx.fillStyle = '#aaffaa';
            ctx.fillText(labelInfo.desc, 128, 65);

            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#ffd700';
            ctx.fillText('ğŸ’° ' + labelInfo.cost + ' é‡‘å¸', 128, 105);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(12, 6, 1);
            sprite.position.set(x, 8, z);
            sprite.userData = { type: type, isLabel: true };
            sprite.visible = false; // Start hidden, show via updateBuildingLabels
            scene.add(sprite);

            // Store reference for removal when building is built
            game.buildingLabels.push({ type, sprite, spot });

            return spot;
        }

        // Manage label visibility based on game step
        function updateBuildingLabels() {
            game.buildingLabels.forEach(label => {
                let shouldShow = false;

                switch (label.type) {
                    case 'meat_factory':
                        // Show meat factory label at step 4 (after enemies spawn, before building)
                        shouldShow = !game.meatFactoryBuilt && game.step >= 4;
                        break;
                    case 'worker_hut':
                        // Show worker hut label at step 8 (after thunderbird healthy)
                        shouldShow = !game.workerHutBuilt && game.step >= 8;
                        break;
                    case 'upgrade_meat_factory':
                        // Show upgrade label at step 9 (after worker hut built)
                        shouldShow = game.meatFactoryBuilt && !game.meatFactoryUpgraded && game.step >= 9;
                        break;
                }

                if (label.sprite) label.sprite.visible = shouldShow;
                if (label.spot) label.spot.visible = shouldShow || game.meatFactoryBuilt || game.workerHutBuilt;
            });
        }

        function createPlayer() {
            // Simple character: body + head
            const group = new THREE.Group();

            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.8, 1, 2, 8);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0x9370DB }); // Purple
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1;
            body.castShadow = true;
            group.add(body);

            // Head
            const headGeo = new THREE.SphereGeometry(0.6, 16, 16);
            const headMat = new THREE.MeshPhongMaterial({ color: 0xFFE4C4 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 2.5;
            head.castShadow = true;
            group.add(head);

            // Hair (blonde)
            const hairGeo = new THREE.SphereGeometry(0.65, 16, 16);
            const hairMat = new THREE.MeshPhongMaterial({ color: 0xFFD700 });
            const hair = new THREE.Mesh(hairGeo, hairMat);
            hair.position.set(0, 2.7, -0.1);
            hair.scale.set(1, 0.8, 1);
            group.add(hair);

            group.position.set(0, 0, 0);
            scene.add(group);

            playerMesh = group;
            player = { x: 0, z: 0, mesh: group };
        }

        // ==================== BEAST SYSTEM ====================
        function createBeastMesh(type, stage) {
            const group = new THREE.Group();

            if (type === 'hydra') {
                const scale = stage === 'evolved' ? 3 : (stage === 'healthy' ? 1.5 : 1);
                const color = stage === 'baby' ? 0x90EE90 : 0x228B22;

                // Body
                const bodyGeo = new THREE.SphereGeometry(1.5 * scale, 16, 16);
                const bodyMat = new THREE.MeshPhongMaterial({ color });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.scale.set(1, 0.6, 1.2);
                body.position.y = 1 * scale;
                body.castShadow = true;
                group.add(body);

                // Heads (1 for baby, 3 for healthy, 9 for evolved)
                const headCount = stage === 'evolved' ? 9 : (stage === 'healthy' ? 3 : 1);
                const headGeo = new THREE.SphereGeometry(0.5 * scale, 12, 12);
                const headMat = new THREE.MeshPhongMaterial({ color });

                for (let i = 0; i < headCount; i++) {
                    const head = new THREE.Mesh(headGeo, headMat);
                    const angle = (i / headCount) * Math.PI - Math.PI / 2;
                    head.position.set(
                        Math.sin(angle) * 1.5 * scale,
                        2 * scale + Math.abs(Math.sin(angle)) * 0.5 * scale,
                        Math.cos(angle) * 0.5 * scale - 1 * scale
                    );
                    head.castShadow = true;
                    group.add(head);
                }

                // Injured indicator
                if (stage === 'baby') {
                    const bandageGeo = new THREE.BoxGeometry(0.8, 0.2, 0.1);
                    const bandageMat = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
                    const bandage = new THREE.Mesh(bandageGeo, bandageMat);
                    bandage.position.set(0, 1.5, 1.2);
                    group.add(bandage);

                    const crossGeo = new THREE.BoxGeometry(0.3, 0.1, 0.05);
                    const crossMat = new THREE.MeshPhongMaterial({ color: 0xFF0000 });
                    const cross1 = new THREE.Mesh(crossGeo, crossMat);
                    cross1.position.set(0, 1.5, 1.25);
                    group.add(cross1);
                }
            } else if (type === 'thunderbird') {
                const scale = stage === 'evolved' ? 3 : (stage === 'healthy' ? 1.5 : 1);
                const color = stage === 'baby' ? 0x87CEEB : 0x4169E1;

                // Body
                const bodyGeo = new THREE.SphereGeometry(1 * scale, 16, 16);
                const bodyMat = new THREE.MeshPhongMaterial({ color });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.scale.set(1, 0.8, 1.5);
                body.position.y = 2 * scale;
                body.castShadow = true;
                group.add(body);

                // Head
                const headGeo = new THREE.SphereGeometry(0.6 * scale, 12, 12);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.position.set(0, 2.5 * scale, -0.8 * scale);
                head.castShadow = true;
                group.add(head);

                // Beak
                const beakGeo = new THREE.ConeGeometry(0.2 * scale, 0.5 * scale, 8);
                const beakMat = new THREE.MeshPhongMaterial({ color: 0xFFA500 });
                const beak = new THREE.Mesh(beakGeo, beakMat);
                beak.rotation.x = Math.PI / 2;
                beak.position.set(0, 2.4 * scale, -1.5 * scale);
                group.add(beak);

                // Wings
                const wingGeo = new THREE.BoxGeometry(3 * scale, 0.2 * scale, 1.5 * scale);
                const wingMat = new THREE.MeshPhongMaterial({ color });

                const leftWing = new THREE.Mesh(wingGeo, wingMat);
                leftWing.position.set(-2 * scale, 2 * scale, 0);
                leftWing.rotation.z = 0.3;
                leftWing.castShadow = true;
                group.add(leftWing);

                const rightWing = new THREE.Mesh(wingGeo, wingMat);
                rightWing.position.set(2 * scale, 2 * scale, 0);
                rightWing.rotation.z = -0.3;
                rightWing.castShadow = true;
                group.add(rightWing);

                // Lightning effect for evolved
                if (stage === 'evolved') {
                    const lightningMat = new THREE.MeshBasicMaterial({
                        color: 0xFFFF00,
                        transparent: true,
                        opacity: 0.8
                    });
                    for (let i = 0; i < 5; i++) {
                        const boltGeo = new THREE.CylinderGeometry(0.1, 0.1, 2, 4);
                        const bolt = new THREE.Mesh(boltGeo, lightningMat);
                        bolt.position.set(
                            (Math.random() - 0.5) * 6,
                            1 + Math.random() * 3,
                            (Math.random() - 0.5) * 4
                        );
                        bolt.rotation.set(Math.random(), Math.random(), Math.random());
                        group.add(bolt);
                    }
                }

                // Injured indicator
                if (stage === 'baby') {
                    const bandageGeo = new THREE.BoxGeometry(0.6, 0.15, 0.08);
                    const bandageMat = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
                    const bandage = new THREE.Mesh(bandageGeo, bandageMat);
                    bandage.position.set(0, 2.8, -0.8);
                    group.add(bandage);
                }
            }

            return group;
        }

        // Create a green guide arrow pointing down
        function createGuideArrow() {
            const group = new THREE.Group();

            // Arrow body (cone pointing down)
            const coneGeo = new THREE.ConeGeometry(0.8, 2, 8);
            const coneMat = new THREE.MeshBasicMaterial({ color: 0x00FF00 });
            const cone = new THREE.Mesh(coneGeo, coneMat);
            cone.rotation.x = Math.PI; // Point downward
            cone.position.y = 0;
            group.add(cone);

            // Arrow stem
            const stemGeo = new THREE.CylinderGeometry(0.3, 0.3, 1, 8);
            const stem = new THREE.Mesh(stemGeo, coneMat);
            stem.position.y = 1.5;
            group.add(stem);

            return group;
        }

        function spawnInjuredHydra() {
            if (game.hydraSpawned) return;
            game.hydraSpawned = true;

            const mesh = createBeastMesh('hydra', 'baby');
            mesh.position.set(-10, 0, 15);
            scene.add(mesh);

            // Create guide arrow above the beast
            const guideArrow = createGuideArrow();
            guideArrow.position.set(-10, 6, 15);
            scene.add(guideArrow);

            game.beasts.push({
                type: 'hydra',
                stage: 'baby',
                feedProgress: 0,
                mesh: mesh,
                x: -10,
                z: 15,
                captured: false,
                attackCooldown: 0,
                skills: [],
                level: 0,
                feedCount: 0,
                guideArrow: guideArrow // Store reference to remove later
            });

            showPrompt('ğŸ’” å‘ç°å—ä¼¤çš„å¹¼å¹´ä¹å¤´è›‡ï¼é è¿‘æ•è·ï¼');
            updateBeastPanel();
        }

        function spawnThunderbird() {
            if (game.thunderbirdSpawned) return;
            game.thunderbirdSpawned = true;

            const mesh = createBeastMesh('thunderbird', 'baby');
            mesh.position.set(0, 0, -30);
            scene.add(mesh);

            // Create guide arrow above the beast
            const guideArrow = createGuideArrow();
            guideArrow.position.set(0, 8, -30); // Higher for thunderbird
            scene.add(guideArrow);

            game.beasts.push({
                type: 'thunderbird',
                stage: 'baby',
                feedProgress: 0,
                mesh: mesh,
                x: 0,
                z: -30,
                captured: false,
                attackCooldown: 0,
                skills: [],
                level: 0,
                feedCount: 0,
                guideArrow: guideArrow
            });

            showPrompt('ğŸ¦… åŸå¤–å‘ç°å—ä¼¤çš„é›·é¹é¸Ÿï¼å‰å¾€æ•è·ï¼');
            updateBeastPanel();
        }

        function captureBeast(beast) {
            if (beast.captured) return;
            beast.captured = true;

            // Remove guide arrow
            if (beast.guideArrow) {
                scene.remove(beast.guideArrow);
                beast.guideArrow = null;
            }

            // Move to pen with better spacing
            const capturedCount = game.beasts.filter(b => b.captured).length;
            const penX = -12 + (capturedCount - 1) * 8; // Increased spacing
            beast.x = penX;
            beast.z = 10;
            beast.mesh.position.set(penX, 0, 10);

            SoundManager.playCapture();
            showPrompt(`âœ… æˆåŠŸæ•è·${beast.type === 'hydra' ? 'ä¹å¤´è›‡' : 'é›·é¹é¸Ÿ'}ï¼ç”¨è‚‰å—å–‚å…»å®ƒï¼`);
            updateBeastPanel();
            advanceStep();
        }

        function feedBeast(beast) {
            if (game.meat < CONFIG.feedCost) {
                showPrompt('âŒ è‚‰å—ä¸è¶³ï¼éœ€è¦ ' + CONFIG.feedCost + ' è‚‰å—');
                return;
            }

            game.meat -= CONFIG.feedCost;
            beast.feedProgress += CONFIG.feedProgressPerFeed;

            if (beast.feedProgress >= 100) {
                beast.feedProgress = 0;
                evolveBeast(beast);
            } else {
                SoundManager.playFeed();
                showPrompt(`ğŸ¥© å–‚é£ŸæˆåŠŸï¼è¿›åº¦: ${beast.feedProgress}%`);
            }

            updateHUD();
            updateBeastPanel();
        }

        function evolveBeast(beast) {
            beast.feedCount++;

            // Determine what happens based on feed count
            // Feed 1: baby -> healthy (no skill choice)
            // Feed 2: healthy -> level1 (skill choice 1)
            // Feed 3: level1 -> level2 (skill choice 2)
            // Feed 4: level2 -> level3 (skill choice 3)
            // Feed 5: level3 -> evolved (ultimate skill choice)

            const wasStage = beast.stage;
            let needsSkillSelection = false;
            let skillLevel = null;

            if (beast.feedCount === 1) {
                // First feed: baby -> healthy, no skill choice
                beast.stage = 'healthy';
                beast.level = 0;
                SoundManager.playEvolve();
                showPrompt(`ğŸ’š ${beast.type === 'hydra' ? 'ä¹å¤´è›‡' : 'é›·é¹é¸Ÿ'}æ¢å¤å¥åº·ï¼å¯ä»¥æˆ˜æ–—äº†ï¼`);
            } else if (beast.feedCount === 2) {
                // Second feed: healthy -> level1, skill choice 1
                beast.stage = 'level1';
                beast.level = 1;
                needsSkillSelection = true;
                skillLevel = 1;
            } else if (beast.feedCount === 3) {
                // Third feed: level1 -> level2, skill choice 2
                beast.stage = 'level2';
                beast.level = 2;
                needsSkillSelection = true;
                skillLevel = 2;
            } else if (beast.feedCount === 4) {
                // Fourth feed: level2 -> level3, skill choice 3
                beast.stage = 'level3';
                beast.level = 3;
                needsSkillSelection = true;
                skillLevel = 3;
            } else if (beast.feedCount === 5) {
                // Fifth feed: level3 -> evolved, ultimate skill choice
                beast.stage = 'evolved';
                beast.level = 4;
                needsSkillSelection = true;
                skillLevel = 'ultimate';
            }

            // Update mesh if stage changed visually
            if (wasStage !== beast.stage) {
                scene.remove(beast.mesh);
                // Map stage to visual mesh (only baby, healthy, evolved have unique visuals)
                const visualStage = beast.stage === 'evolved' ? 'evolved' :
                    (beast.stage === 'baby' ? 'baby' : 'healthy');
                beast.mesh = createBeastMesh(beast.type, visualStage);
                beast.mesh.position.set(beast.x, 0, beast.z);
                scene.add(beast.mesh);
            }

            updateBeastPanel();

            if (needsSkillSelection) {
                showSkillSelection(beast, skillLevel);
            } else {
                // Handle step progression for first evolution (no skill selection)
                handleStepProgression(beast, wasStage);
            }
        }

        function showSkillSelection(beast, skillLevel) {
            const skills = BEAST_SKILLS[beast.type][skillLevel];
            const modal = document.getElementById('skillModal');
            const title = document.getElementById('skillModalTitle');
            const choices = document.getElementById('skillChoices');

            const beastName = beast.type === 'hydra' ? 'ä¹å¤´è›‡' : 'é›·é¹é¸Ÿ';
            const isUltimate = skillLevel === 'ultimate';
            title.innerHTML = isUltimate ?
                `âš¡ ${beastName}ç»ˆææŠ€èƒ½ âš¡` :
                `ğŸŒŸ ${beastName}æŠ€èƒ½å‡çº§ Lv.${skillLevel} ğŸŒŸ`;

            choices.innerHTML = skills.map((skill, idx) => `
                <button onclick="selectSkill('${beast.type}', ${idx}, '${skillLevel}')" style="
                    background: ${isUltimate ? 'linear-gradient(135deg, #ff6b00, #ffd700)' : 'linear-gradient(135deg, #4a0080, #0080ff)'};
                    border: 2px solid ${isUltimate ? '#ffd700' : '#00ffff'};
                    border-radius: 10px;
                    padding: 20px;
                    min-width: 180px;
                    cursor: pointer;
                    color: white;
                    transition: transform 0.2s;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    <div style="font-size: 32px; margin-bottom: 10px;">${skill.emoji || (isUltimate ? 'âš¡' : 'âœ¨')}</div>
                    <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;">${skill.name}</div>
                    <div style="font-size: 14px; opacity: 0.9;">${skill.desc}</div>
                </button>
            `).join('');

            modal.style.display = 'flex';
        }

        window.selectSkill = function (beastType, skillIndex, skillLevel) {
            const beast = game.beasts.find(b => b.type === beastType);
            const skill = BEAST_SKILLS[beastType][skillLevel][skillIndex];

            beast.skills.push(skill);

            document.getElementById('skillModal').style.display = 'none';

            SoundManager.playSkillSelect();

            const beastName = beastType === 'hydra' ? 'ä¹å¤´è›‡' : 'é›·é¹é¸Ÿ';
            const isUltimate = skillLevel === 'ultimate';

            if (isUltimate) {
                showPrompt(`âš¡ ${beastName}è·å¾—ç»ˆææŠ€èƒ½: ${skill.name}ï¼æˆ˜åŠ›æš´å¢ï¼`);
            } else {
                showPrompt(`âœ¨ ${beastName}å­¦ä¼šäº†: ${skill.name}ï¼`);
            }

            updateBeastPanel();

            // Handle step progression after skill selection
            const wasStage = beast.feedCount === 1 ? 'baby' :
                beast.feedCount === 2 ? 'healthy' :
                    beast.feedCount === 3 ? 'level1' :
                        beast.feedCount === 4 ? 'level2' : 'level3';
            handleStepProgression(beast, wasStage);
        };

        function handleStepProgression(beast, wasStage) {
            // Step progression for first evolution (baby -> healthy)
            if (beast.type === 'hydra' && wasStage === 'baby' && beast.stage === 'healthy') {
                // Step 3: Hydra healthy, then auto-trigger step 4 (enemies)
                advanceStep(); // -> step 3
                setTimeout(() => advanceStep(), 1000); // -> step 4 (enemies spawn)
            } else if (beast.type === 'thunderbird' && wasStage === 'baby' && beast.stage === 'healthy') {
                // Step 8: Thunderbird healthy (after first feed)
                if (game.step < 8) game.step = 7;
                advanceStep(); // -> step 8
            }

            // Check if ANY beast reaches feedCount >= 4 for boss spawn
            if (beast.feedCount >= 4 && !game.bossSpawned) {
                showPrompt('âš¡ å·¨å…½å®åŠ›å¼ºå¤§ï¼æœ€ç»ˆBOSSå³å°†å‡ºç°ï¼');
                game.step = 12; // Jump to boss step
                setTimeout(() => advanceStep(), 3000); // -> step 13 (boss spawns)
            }
        }

        // ==================== BUILDING SYSTEM ====================
        function createBuilding(type, x, z) {
            const group = new THREE.Group();

            if (type === 'meat_factory') {
                // Factory building
                const baseGeo = new THREE.BoxGeometry(6, 4, 6);
                const baseMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = 2;
                base.castShadow = true;
                group.add(base);

                // Chimney
                const chimneyGeo = new THREE.CylinderGeometry(0.5, 0.5, 3, 8);
                const chimneyMat = new THREE.MeshPhongMaterial({ color: 0x696969 });
                const chimney = new THREE.Mesh(chimneyGeo, chimneyMat);
                chimney.position.set(2, 5.5, 0);
                chimney.castShadow = true;
                group.add(chimney);

                // Sign
                const signGeo = new THREE.BoxGeometry(2, 1, 0.1);
                const signMat = new THREE.MeshPhongMaterial({ color: 0xFF6347 });
                const sign = new THREE.Mesh(signGeo, signMat);
                sign.position.set(0, 4.5, 3.1);
                group.add(sign);
            } else if (type === 'worker_hut') {
                // Hut building
                const baseGeo = new THREE.BoxGeometry(5, 3, 5);
                const baseMat = new THREE.MeshPhongMaterial({ color: 0xDEB887 });
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = 1.5;
                base.castShadow = true;
                group.add(base);

                // Roof
                const roofGeo = new THREE.ConeGeometry(4, 2, 4);
                const roofMat = new THREE.MeshPhongMaterial({ color: 0x8B0000 });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.y = 4;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                group.add(roof);
            }

            group.position.set(x, 0, z);
            scene.add(group);

            return {
                type,
                x,
                z,
                mesh: group,
                level: 1
            };
        }

        function removeBuildingLabel(type) {
            const idx = game.buildingLabels.findIndex(l => l.type === type);
            if (idx >= 0) {
                const label = game.buildingLabels[idx];
                scene.remove(label.sprite);
                scene.remove(label.spot);
                game.buildingLabels.splice(idx, 1);
            }
        }

        function showUpgradeLabel(x, z) {
            // Create upgrade label
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.roundRect(0, 0, 256, 128, 10);
            ctx.fill();
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 26px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('â¬†ï¸ å‡çº§é€ è‚‰å‚', 128, 40);

            ctx.font = '18px Arial';
            ctx.fillStyle = '#aaffaa';
            ctx.fillText('äº§å‡ºæ•ˆç‡ç¿»å€', 128, 70);

            ctx.font = 'bold 22px Arial';
            ctx.fillStyle = '#ffd700';
            ctx.fillText('ğŸ’° ' + CONFIG.upgradeMeatFactoryCost + ' é‡‘å¸', 128, 105);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(12, 6, 1);
            sprite.position.set(x, 10, z);
            sprite.userData = { type: 'upgrade_meat_factory', isLabel: true };
            sprite.visible = false; // Start hidden, managed by updateBuildingLabels
            scene.add(sprite);
            game.buildingLabels.push({ type: 'upgrade_meat_factory', sprite, spot: null });
        }

        function buildMeatFactory() {
            if (game.meatFactoryBuilt) return;
            if (game.coins < CONFIG.meatFactoryCost) {
                showPrompt('âŒ é‡‘å¸ä¸è¶³ï¼éœ€è¦ ' + CONFIG.meatFactoryCost + ' é‡‘å¸');
                return;
            }

            game.coins -= CONFIG.meatFactoryCost;
            game.meatFactoryBuilt = true;

            // Remove construction label
            removeBuildingLabel('meat_factory');

            const building = createBuilding('meat_factory', 15, 10);
            game.buildings.push(building);

            SoundManager.playBuild();
            showPrompt('ğŸ­ é€ è‚‰å‚å»ºæˆï¼è‡ªåŠ¨ç”Ÿäº§è‚‰å—ï¼');
            updateHUD();

            // Advance from step 4 to step 5, then immediately to step 6 (thunderbird)
            game.step = 5; // Complete building step
            advanceStep(); // Move to step 6, triggers thunderbird spawn
        }

        function buildWorkerHut() {
            if (game.workerHutBuilt) return;
            if (game.coins < CONFIG.workerHutCost) {
                showPrompt('âŒ é‡‘å¸ä¸è¶³ï¼éœ€è¦ ' + CONFIG.workerHutCost + ' é‡‘å¸');
                return;
            }

            game.coins -= CONFIG.workerHutCost;
            game.workerHutBuilt = true;

            // Remove construction label
            removeBuildingLabel('worker_hut');

            const building = createBuilding('worker_hut', 15, -5);
            game.buildings.push(building);

            // Spawn workers
            for (let i = 0; i < 4; i++) {
                spawnWorker(15 + (i - 1.5) * 2, -5);
            }

            showPrompt('ğŸ  å·¥äººå°å±‹å»ºæˆï¼4ä¸ªå·¥äººè‡ªåŠ¨æ”¶é›†èµ„æºï¼');
            updateHUD();

            // Advance from step 8 to step 9
            game.step = 8;
            advanceStep(); // Move to step 9
        }

        function upgradeMeatFactory() {
            if (game.meatFactoryUpgraded) return;
            if (game.coins < CONFIG.upgradeMeatFactoryCost) {
                showPrompt('âŒ é‡‘å¸ä¸è¶³ï¼éœ€è¦ ' + CONFIG.upgradeMeatFactoryCost + ' é‡‘å¸');
                return;
            }

            game.coins -= CONFIG.upgradeMeatFactoryCost;
            game.meatFactoryUpgraded = true;

            // Remove upgrade label
            removeBuildingLabel('upgrade_meat_factory');

            showPrompt('â¬†ï¸ é€ è‚‰å‚å‡çº§ï¼äº§å‡ºæ•ˆç‡å¤§å¹…æå‡ï¼');
            updateHUD();

            // Advance from step 9 to step 10
            game.step = 9;
            advanceStep(); // Move to step 10
        }

        function spawnWorker(x, z) {
            const group = new THREE.Group();

            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.4, 0.5, 1.2, 8);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0x4682B4 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.6;
            body.castShadow = true;
            group.add(body);

            // Head
            const headGeo = new THREE.SphereGeometry(0.35, 12, 12);
            const headMat = new THREE.MeshPhongMaterial({ color: 0xFFE4C4 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.5;
            head.castShadow = true;
            group.add(head);

            group.position.set(x, 0, z);
            scene.add(group);

            game.workers.push({
                mesh: group,
                x,
                z,
                targetLoot: null
            });
        }

        // ==================== ENEMY SYSTEM ====================
        function createEnemyMesh(type) {
            const group = new THREE.Group();

            if (type === 'dark_spirit') {
                // Dark ghostly body
                const bodyGeo = new THREE.SphereGeometry(1, 12, 12);
                const bodyMat = new THREE.MeshPhongMaterial({
                    color: 0x4B0082,
                    transparent: true,
                    opacity: 0.8
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.scale.set(1, 1.3, 1);
                body.position.y = 1.5;
                body.castShadow = true;
                group.add(body);

                // Glowing eyes
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                const eyeGeo = new THREE.SphereGeometry(0.15, 8, 8);

                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-0.3, 1.8, 0.8);
                group.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(0.3, 1.8, 0.8);
                group.add(rightEye);
            } else if (type === 'boss') {
                // Giant dark beast
                const bodyGeo = new THREE.SphereGeometry(3, 16, 16);
                const bodyMat = new THREE.MeshPhongMaterial({
                    color: 0x1a0033,
                    transparent: true,
                    opacity: 0.9
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 3;
                body.castShadow = true;
                group.add(body);

                // Horns
                const hornGeo = new THREE.ConeGeometry(0.5, 2, 6);
                const hornMat = new THREE.MeshPhongMaterial({ color: 0x8B0000 });

                const leftHorn = new THREE.Mesh(hornGeo, hornMat);
                leftHorn.position.set(-1.5, 5, 0);
                leftHorn.rotation.z = 0.3;
                group.add(leftHorn);

                const rightHorn = new THREE.Mesh(hornGeo, hornMat);
                rightHorn.position.set(1.5, 5, 0);
                rightHorn.rotation.z = -0.3;
                group.add(rightHorn);

                // Giant eyes
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                const eyeGeo = new THREE.SphereGeometry(0.4, 8, 8);

                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-1, 4, 2.5);
                group.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(1, 4, 2.5);
                group.add(rightEye);
            }

            return group;
        }

        function spawnEnemy() {
            // Spawn from map edges (closer to fence)
            const side = Math.floor(Math.random() * 4);
            let x, z;

            switch (side) {
                case 0: x = -30; z = Math.random() * 50 - 25; break;
                case 1: x = 30; z = Math.random() * 50 - 25; break;
                case 2: x = Math.random() * 50 - 25; z = -30; break;
                case 3: x = Math.random() * 50 - 25; z = 30; break;
            }

            const mesh = createEnemyMesh('dark_spirit');
            mesh.position.set(x, 0, z);
            scene.add(mesh);

            game.enemies.push({
                type: 'dark_spirit',
                hp: 20,
                maxHp: 20,
                mesh,
                x,
                z,
                speed: 5
            });
        }

        function spawnBoss() {
            if (game.bossSpawned) return;
            game.bossSpawned = true;

            const mesh = createEnemyMesh('boss');
            mesh.position.set(0, 0, -50);
            scene.add(mesh);

            game.enemies.push({
                type: 'boss',
                isBoss: true, // Flag for priority targeting
                hp: CONFIG.bossHp,
                maxHp: CONFIG.bossHp,
                mesh,
                x: 0,
                z: -50,
                speed: 6 // Doubled for challenge
            });

            SoundManager.playBossSpawn();
            showPrompt('âš ï¸ æœ€ç»ˆBOSSå‡ºç°ï¼å‡†å¤‡æˆ˜æ–—ï¼');

            // Show boss health bar
            document.getElementById('bossHealthBar').style.display = 'block';
            updateBossHealthBar();
        }

        // ==================== LOOT SYSTEM ====================
        function spawnLoot(x, z, type) {
            const group = new THREE.Group();

            if (type === 'meat') {
                const meatGeo = new THREE.SphereGeometry(0.5, 8, 8);
                const meatMat = new THREE.MeshPhongMaterial({ color: 0xCD5C5C });
                const meat = new THREE.Mesh(meatGeo, meatMat);
                meat.position.y = 0.5;
                meat.castShadow = true;
                group.add(meat);
            } else if (type === 'coin') {
                const coinGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16);
                const coinMat = new THREE.MeshPhongMaterial({ color: 0xFFD700 });
                const coin = new THREE.Mesh(coinGeo, coinMat);
                coin.rotation.x = Math.PI / 2;
                coin.position.y = 0.5;
                coin.castShadow = true;
                group.add(coin);
            }

            group.position.set(x, 0, z);
            scene.add(group);

            game.loot.push({ type, mesh: group, x, z });
        }

        // ==================== UI FUNCTIONS ====================
        function showPrompt(text) {
            const box = document.getElementById('promptBox');
            box.textContent = text;
            box.style.display = 'block';

            clearTimeout(box.hideTimeout);
            box.hideTimeout = setTimeout(() => {
                box.style.display = 'none';
            }, 3000);
        }

        function updateHUD() {
            document.getElementById('meatCount').textContent = Math.floor(game.meat);
            document.getElementById('coinCount').textContent = Math.floor(game.coins);
        }

        function updateBossHealthBar() {
            const boss = game.enemies.find(e => e.isBoss);
            const bossBar = document.getElementById('bossHealthBar');

            if (boss) {
                bossBar.style.display = 'block';
                const hpPercent = Math.max(0, (boss.hp / boss.maxHp) * 100);
                document.getElementById('bossHpFill').style.width = hpPercent + '%';
                document.getElementById('bossHpText').textContent = `${Math.max(0, Math.floor(boss.hp))} / ${boss.maxHp}`;
            } else if (game.bossSpawned) {
                // Boss defeated - hide bar
                bossBar.style.display = 'none';
            }
        }

        function updateBeastPanel() {
            const panel = document.getElementById('beastPanel');
            panel.innerHTML = '';

            game.beasts.forEach((beast) => {
                if (!beast.captured) return; // Only show captured beasts

                const card = document.createElement('div');
                card.className = 'beast-card' + (beast.stage !== 'baby' ? ' active' : '');

                const stageName = beast.stage === 'baby' ? 'å—ä¼¤' :
                    beast.stage === 'healthy' ? 'å¥åº·' :
                        beast.stage === 'level1' ? 'æˆé•¿Lv.1' :
                            beast.stage === 'level2' ? 'æˆé•¿Lv.2' :
                                beast.stage === 'level3' ? 'æˆé•¿Lv.3' : 'å·¨å‹';
                const name = beast.type === 'hydra' ? 'ä¹å¤´è›‡' : 'é›·é¹é¸Ÿ';

                const canFeed = beast.captured && beast.stage !== 'evolved' && game.meat >= CONFIG.feedCost;
                const isInjured = beast.stage === 'baby';
                const feedBtnText = beast.stage === 'evolved' ? 'å·²è¿›åŒ–' :
                    isInjured ? `ğŸ’š æ²»ç–— (${CONFIG.feedCost}è‚‰å—)` :
                        `â¬†ï¸ å‡çº§ (${CONFIG.feedCost}è‚‰å—)`;
                const btnColor = isInjured ? 'background: linear-gradient(135deg, #22c55e, #16a34a);' : '';

                card.innerHTML = `
                <div class="name">${beast.type === 'hydra' ? 'ğŸ' : 'ğŸ¦…'} ${name}</div>
                <div class="stage">çŠ¶æ€: ${stageName}</div>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${beast.feedProgress}%"></div>
                </div>
                <button class="feed-btn" 
                    ${!canFeed ? 'disabled' : ''}
                    style="${btnColor}"
                    onclick="feedBeastByType('${beast.type}')">
                    ${feedBtnText}
                </button>
            `;

                panel.appendChild(card);
            });
        }

        // Global feed function for button onclick - uses beast type as unique ID
        window.feedBeastByType = function (type) {
            const beast = game.beasts.find(b => b.type === type && b.captured);
            if (beast && beast.stage !== 'evolved') {
                feedBeast(beast);
            }
        };

        function showVictory() {
            document.getElementById('victoryScreen').style.display = 'flex';
        }

        // ==================== GAME FLOW ====================
        // 15-Step Sequence:
        // 1: Capture Hydra | 2: Feed Hydra | 3: Hydra Healthy
        // 4: Enemies spawn | 5: Build Meat Factory | 6: Thunderbird appears
        // 7: Capture Thunderbird | 8: Feed Thunderbird | 9: Build Worker Hut
        // 10: Upgrade Meat Factory | 11: Hydra evolves | 12: Thunderbird evolves
        // 13: Boss spawns | 14: Boss defeated | 15: Victory

        function advanceStep() {
            game.step++;
            console.log('Advancing to step:', game.step);

            switch (game.step) {
                case 2: // After capturing Hydra
                    showPrompt('ğŸ¥© ç”¨è‚‰å—å–‚å…»ä¹å¤´è›‡ï¼é è¿‘å®ƒå³å¯å–‚é£Ÿ');
                    break;
                case 3: // Hydra becomes healthy
                    // Triggers enemy spawning
                    break;
                case 4: // Enemies start spawning
                    showPrompt('âš”ï¸ é»‘æš—çµæ¥è¢­ï¼ä¹å¤´è›‡ä¼šè‡ªåŠ¨æ”»å‡»ï¼å‡»æ€è·å¾—é‡‘å¸');
                    break;
                case 5: // Can build meat factory (need 50 coins)
                    showPrompt('ğŸ—ï¸ æ”¶é›†50é‡‘å¸åï¼Œèµ°åˆ°å»ºç­‘ç‚¹å»ºé€ é€ è‚‰å‚ï¼');
                    break;
                case 6: // Thunderbird appears after meat factory built
                    setTimeout(() => spawnThunderbird(), 2000);
                    break;
                case 7: // After capturing Thunderbird
                    showPrompt('ğŸ¥© ç”¨é€ è‚‰å‚äº§å‡ºçš„è‚‰å—å–‚å…»é›·é¹é¸Ÿï¼');
                    break;
                case 8: // Thunderbird healthy
                    showPrompt('ğŸ’ª é›·é¹é¸Ÿæ¢å¤å¥åº·ï¼æ”¶é›†80é‡‘å¸å»ºé€ å·¥äººå°å±‹');
                    break;
                case 9: // After building worker hut
                    showPrompt('â¬†ï¸ æ”¶é›†100é‡‘å¸å‡çº§é€ è‚‰å‚ï¼');
                    break;
                case 10: // After upgrading meat factory
                    showPrompt('ğŸ ç»§ç»­å–‚å…»ä¹å¤´è›‡è®©å®ƒè¿›åŒ–ï¼');
                    break;
                case 11: // Hydra evolved
                    showPrompt('âš¡ ä¹å¤´è›‡è¿›åŒ–æˆå·¨å‹ï¼ç»§ç»­å–‚å…»é›·é¹é¸Ÿï¼');
                    break;
                case 12: // Thunderbird evolved
                    showPrompt('ğŸŒŸ åŒå·¨å…½è¿›åŒ–å®Œæˆï¼å‡†å¤‡è¿æˆ˜æœ€ç»ˆBOSSï¼');
                    break;
                case 13: // Boss spawns
                    setTimeout(() => spawnBoss(), CONFIG.bossSpawnDelay * 1000);
                    break;
                case 14: // Boss defeated
                    advanceStep(); // Auto-advance to victory
                    break;
                case 15: // Victory
                    setTimeout(showVictory, 2000);
                    break;
            }
        }

        // ==================== GAME UPDATE ====================
        function update(dt) {
            if (!game.started) return;

            // Player movement
            let moveX = 0, moveZ = 0;

            if (keys.w) moveZ -= 1;
            if (keys.s) moveZ += 1;
            if (keys.a) moveX -= 1;
            if (keys.d) moveX += 1;

            // Apply joystick
            moveX += joystickVector.x;
            moveZ -= joystickVector.y;

            // Normalize
            const len = Math.sqrt(moveX * moveX + moveZ * moveZ);
            if (len > 0) {
                moveX /= len;
                moveZ /= len;

                player.x += moveX * CONFIG.playerSpeed * dt;
                player.z += moveZ * CONFIG.playerSpeed * dt;

                // Clamp to bounds
                player.x = Math.max(-35, Math.min(35, player.x));
                player.z = Math.max(-35, Math.min(35, player.z));

                playerMesh.position.set(player.x, 0, player.z);

                // Face movement direction
                playerMesh.rotation.y = Math.atan2(moveX, -moveZ);
            }

            // Camera follows player
            camera.position.x = player.x;
            camera.position.z = player.z + 30;
            camera.lookAt(player.x, 0, player.z);

            // Check interactions
            checkBeastInteractions();
            checkBuildingInteractions();
            checkLootCollection();

            // Update beasts
            updateBeasts(dt);

            // Update projectiles
            updateProjectiles(dt);

            // Update enemies
            updateEnemies(dt);

            // Update workers
            updateWorkers(dt);

            // Meat production - spawn VISIBLE loot near factory
            if (game.meatFactoryBuilt) {
                game.meatProductionTimer += dt;
                const rate = game.meatFactoryUpgraded ? CONFIG.meatProductionRateUpgraded : CONFIG.meatProductionRate;
                // Spawn meat every 2 seconds
                if (game.meatProductionTimer >= 2) {
                    // Spawn meat OUTSIDE the factory building (offset from 15,10)
                    const offsetX = (Math.random() - 0.5) * 6; // -3 to +3
                    const offsetZ = 5 + Math.random() * 3; // 5-8 in front
                    spawnLoot(15 + offsetX, 10 + offsetZ, 'meat');
                    game.meatProductionTimer = 0;
                }
            }

            // Enemy spawning (after step 2 - right after hydra captured, until boss spawns at step 13)
            if (game.step >= 2 && game.step < 13) {
                game.enemySpawnTimer += dt;
                if (game.enemySpawnTimer >= CONFIG.enemySpawnInterval) {
                    // Spawn 2-3 enemies at once for more challenge
                    const spawnCount = Math.floor(Math.random() * 2) + 2; // 2 or 3 enemies
                    for (let i = 0; i < spawnCount; i++) {
                        spawnEnemy();
                    }
                    game.enemySpawnTimer = 0;
                }
            }

            // Fence regeneration
            const enemiesAttackingFence = game.enemies.some(e => e.attackingFence);
            if (!enemiesAttackingFence && game.fenceHealth < CONFIG.fenceMaxHp) {
                game.fenceRegenTimer += dt;
                if (game.fenceRegenTimer >= 1) {
                    game.fenceHealth = Math.min(CONFIG.fenceMaxHp, game.fenceHealth + CONFIG.fenceRegenRate);
                    game.fenceRegenTimer = 0;
                }
            } else {
                game.fenceRegenTimer = 0;
            }
            game.fenceUnderAttack = enemiesAttackingFence;

            // Update building label visibility based on step
            updateBuildingLabels();

            // Update boss health bar
            if (game.bossSpawned) {
                updateBossHealthBar();
            }
        }

        function checkBeastInteractions() {
            game.beasts.forEach(beast => {
                const dx = player.x - beast.x;
                const dz = player.z - beast.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                // Capture
                if (!beast.captured && dist < 3) {
                    captureBeast(beast);
                }

                // NOTE: Feeding now requires clicking the button in beast panel
            });
        }

        function checkBuildingInteractions() {
            // Meat factory spot - available after enemies spawn (step 4)
            // Building it advances to step 5, triggering thunderbird spawn
            if (!game.meatFactoryBuilt && game.step >= 4) {
                const dx = player.x - 15;
                const dz = player.z - 10;
                if (Math.sqrt(dx * dx + dz * dz) < 5) {
                    buildMeatFactory();
                }
            }

            // Worker hut spot - available after thunderbird healthy (step 8)
            // Building it advances to step 9
            if (!game.workerHutBuilt && game.step >= 8) {
                const dx = player.x - 15;
                const dz = player.z + 5;
                if (Math.sqrt(dx * dx + dz * dz) < 5) {
                    buildWorkerHut();
                }
            }

            // Upgrade meat factory - available after worker hut built (step 9)
            // Upgrading it advances to step 10
            if (game.meatFactoryBuilt && !game.meatFactoryUpgraded && game.step >= 9) {
                const dx = player.x - 15;
                const dz = player.z - 10;
                if (Math.sqrt(dx * dx + dz * dz) < 5) {
                    upgradeMeatFactory();
                }
            }
        }

        function checkLootCollection() {
            for (let i = game.loot.length - 1; i >= 0; i--) {
                const loot = game.loot[i];
                const dx = player.x - loot.x;
                const dz = player.z - loot.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < CONFIG.collectRange) {
                    if (loot.type === 'meat') game.meat += 2;
                    else if (loot.type === 'coin') game.coins += 15; // Increased from 5 to 15

                    scene.remove(loot.mesh);
                    game.loot.splice(i, 1);
                    SoundManager.playCollect();
                    updateHUD();
                }
            }
        }

        function updateBeasts(dt) {
            game.beasts.forEach(beast => {
                // Animate guide arrow (bounce up and down)
                if (beast.guideArrow && !beast.captured) {
                    const time = Date.now() * 0.003;
                    const baseY = beast.type === 'thunderbird' ? 8 : 6;
                    beast.guideArrow.position.y = baseY + Math.sin(time) * 1.5;
                    beast.guideArrow.position.x = beast.x;
                    beast.guideArrow.position.z = beast.z;
                }

                // Decrease feed cooldown
                if (beast.feedCooldown) {
                    beast.feedCooldown -= dt;
                    if (beast.feedCooldown <= 0) beast.feedCooldown = 0;
                }

                // Only act if captured and healthy/evolved
                if (beast.captured && beast.stage !== 'baby') {
                    beast.attackCooldown -= dt;

                    // Find target - BOSS has HIGHEST priority
                    // When boss exists, both beasts attack boss first
                    let nearest = null;
                    let nearestDist = Infinity;

                    // Check for boss first (priority target)
                    const boss = game.enemies.find(e => e.isBoss);
                    if (boss) {
                        nearest = boss;
                        const dx = beast.x - boss.x;
                        const dz = beast.z - boss.z;
                        nearestDist = Math.sqrt(dx * dx + dz * dz);
                    } else {
                        // Normal territory-based targeting when no boss
                        // Hydra attacks enemies in lower half (z > 0)
                        // Thunderbird attacks enemies in upper half (z <= 0)
                        game.enemies.forEach(enemy => {
                            // Territory filter
                            if (beast.type === 'hydra' && enemy.z < 0) return;
                            if (beast.type === 'thunderbird' && enemy.z > 0) return;

                            const dx = beast.x - enemy.x;
                            const dz = beast.z - enemy.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);

                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearest = enemy;
                            }
                        });
                    }

                    // If no enemy in territory, fallback to any enemy
                    if (!nearest && game.enemies.length > 0) {
                        game.enemies.forEach(enemy => {
                            const dx = beast.x - enemy.x;
                            const dz = beast.z - enemy.z;
                            const dist = Math.sqrt(dx * dx + dz * dz);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearest = enemy;
                            }
                        });
                    }

                    // Auto-move towards distant enemies
                    if (nearest && nearestDist > CONFIG.beastAttackRange) {
                        const dx = nearest.x - beast.x;
                        const dz = nearest.z - beast.z;
                        const moveSpeed = CONFIG.beastMoveSpeed * dt;

                        let newX = beast.x + (dx / nearestDist) * moveSpeed;
                        let newZ = beast.z + (dz / nearestDist) * moveSpeed;

                        // Check collision with other beasts
                        let collisionDetected = false;
                        game.beasts.forEach(otherBeast => {
                            if (otherBeast === beast || !otherBeast.captured) return;

                            const dx2 = newX - otherBeast.x;
                            const dz2 = newZ - otherBeast.z;
                            const dist2 = Math.sqrt(dx2 * dx2 + dz2 * dz2);

                            // Minimum distance based on beast sizes
                            const minDist = (beast.stage === 'evolved' ? 6 : 3) +
                                (otherBeast.stage === 'evolved' ? 6 : 3);

                            if (dist2 < minDist) {
                                collisionDetected = true;
                                // Push away from other beast
                                const pushX = (dx2 / dist2) * moveSpeed * 2;
                                const pushZ = (dz2 / dist2) * moveSpeed * 2;
                                newX += pushX;
                                newZ += pushZ;
                            }
                        });

                        beast.x = newX;
                        beast.z = newZ;
                        beast.mesh.position.set(beast.x, 0, beast.z);

                        // Face direction of movement (add PI because head is in Z-negative direction)
                        beast.mesh.rotation.y = Math.atan2(dx, dz) + Math.PI;
                    }

                    // Ranged attack if in range
                    if (nearest && nearestDist <= CONFIG.beastAttackRange && beast.attackCooldown <= 0) {
                        // Calculate skill-modified damage and effects
                        // Map stage to damage (level1/2/3 scale between healthy and evolved)
                        let baseDamage = CONFIG.beastAttackDamage[beast.stage] ||
                            (beast.stage === 'level1' ? 25 :
                                beast.stage === 'level2' ? 35 :
                                    beast.stage === 'level3' ? 45 : 15);
                        let damageMultiplier = 1;
                        let targetCount = 1;
                        let hasAoe = false;
                        let aoeRadius = 0;
                        let attackSpeedMult = 1;
                        let chainTargets = 0;

                        // Apply skill effects from beast's learned skills
                        if (beast.skills) {
                            beast.skills.forEach(skill => {
                                if (skill.effect.damageMultiplier) damageMultiplier *= skill.effect.damageMultiplier;
                                if (skill.effect.multiTarget) targetCount = Math.max(targetCount, skill.effect.multiTarget);
                                if (skill.effect.aoe) { hasAoe = true; aoeRadius = Math.max(aoeRadius, skill.effect.aoeRadius || 5); }
                                if (skill.effect.attackSpeedMultiplier) attackSpeedMult *= skill.effect.attackSpeedMultiplier;
                                if (skill.effect.chainTarget) chainTargets = Math.max(chainTargets, skill.effect.chainTarget);
                                if (skill.effect.globalAoe) { hasAoe = true; aoeRadius = 30; } // Full screen
                            });
                        }

                        const finalDamage = Math.floor(baseDamage * damageMultiplier);

                        // Multi-target attack: fire at multiple enemies
                        if (targetCount > 1) {
                            // Get up to targetCount enemies
                            const targets = [];
                            const sortedEnemies = [...game.enemies].sort((a, b) => {
                                const distA = Math.sqrt((a.x - beast.x) ** 2 + (a.z - beast.z) ** 2);
                                const distB = Math.sqrt((b.x - beast.x) ** 2 + (b.z - beast.z) ** 2);
                                return distA - distB;
                            });
                            for (let i = 0; i < Math.min(targetCount, sortedEnemies.length); i++) {
                                targets.push(sortedEnemies[i]);
                            }
                            // Fire at each target
                            targets.forEach((target, idx) => {
                                setTimeout(() => {
                                    if (game.enemies.includes(target)) {
                                        fireProjectile(beast, target, finalDamage, hasAoe, aoeRadius, chainTargets);
                                    }
                                }, idx * 50); // Slight delay between shots
                            });
                        } else {
                            // Single target
                            fireProjectile(beast, nearest, finalDamage, hasAoe, aoeRadius, chainTargets);
                        }

                        // Attack cooldown with skill speed multiplier
                        const baseCooldown = Math.max(0.3, 1.0 - (beast.feedCount || 0) * 0.1);
                        beast.attackCooldown = baseCooldown / attackSpeedMult;

                        // Face target (add PI because head is in Z-negative direction)
                        const dx = nearest.x - beast.x;
                        const dz = nearest.z - beast.z;
                        beast.mesh.rotation.y = Math.atan2(dx, dz) + Math.PI;
                    }
                }

                // Idle animation when no enemies
                if (game.enemies.length === 0 && beast.captured && beast.stage !== 'baby') {
                    beast.mesh.rotation.y += dt * 0.3;
                }
            });
        }

        // Create and fire a ranged projectile from beast to enemy
        function fireProjectile(beast, target, damage, hasAoe = false, aoeRadius = 0, chainTargets = 0) {
            // Color varies by beast and skill type
            let color = beast.type === 'hydra' ? 0x00FF00 : 0x00BFFF;
            if (hasAoe && beast.type === 'hydra') color = 0x9932CC; // Purple for poison AOE
            if (hasAoe && beast.type === 'thunderbird') color = 0xFFFF00; // Yellow for thunder AOE
            if (chainTargets > 0) color = 0x00FFFF; // Cyan for chain lightning

            // Size varies by stage and skill type
            let size = beast.stage === 'evolved' ? 0.8 : 0.4;
            if (hasAoe) size *= 1.5; // AOE projectiles are larger

            // Calculate spawn position from beast's HEAD (facing direction)
            const dx = target.x - beast.x;
            const dz = target.z - beast.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            const headOffset = beast.stage === 'evolved' ? 3 : 1.5;
            const spawnX = beast.x + (dx / dist) * headOffset;
            const spawnZ = beast.z + (dz / dist) * headOffset;

            const geo = new THREE.SphereGeometry(size, 8, 8);
            const mat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.9
            });
            const projectile = new THREE.Mesh(geo, mat);
            projectile.position.set(spawnX, 2, spawnZ);
            scene.add(projectile);

            game.projectiles.push({
                mesh: projectile,
                x: spawnX,
                y: 2,
                z: spawnZ,
                targetEnemy: target,
                damage: damage,
                speed: 40,
                hasAoe: hasAoe,
                aoeRadius: aoeRadius,
                chainTargets: chainTargets,
                beastType: beast.type
            });

            SoundManager.playAttack();
        }

        function updateProjectiles(dt) {
            for (let i = game.projectiles.length - 1; i >= 0; i--) {
                const proj = game.projectiles[i];

                // Check if target still exists
                if (!proj.targetEnemy || !game.enemies.includes(proj.targetEnemy)) {
                    scene.remove(proj.mesh);
                    game.projectiles.splice(i, 1);
                    continue;
                }

                // Move towards target
                const dx = proj.targetEnemy.x - proj.x;
                const dy = 1 - proj.y;
                const dz = proj.targetEnemy.z - proj.z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (dist < 1.5) {
                    // Hit primary target
                    proj.targetEnemy.hp -= proj.damage;

                    // AOE splash damage
                    if (proj.hasAoe && proj.aoeRadius > 0) {
                        // Hit all enemies in radius
                        game.enemies.forEach(enemy => {
                            if (enemy === proj.targetEnemy) return; // Skip primary target
                            const edx = enemy.x - proj.x;
                            const edz = enemy.z - proj.z;
                            const eDist = Math.sqrt(edx * edx + edz * edz);
                            if (eDist <= proj.aoeRadius) {
                                // Splash damage (50% of main damage)
                                enemy.hp -= Math.floor(proj.damage * 0.5);
                            }
                        });
                        // AOE visual effect
                        createAoeEffect(proj.x, proj.z, proj.aoeRadius, proj.beastType);
                        SoundManager.playAoe();
                    } else {
                        // Normal hit effect
                        createHitEffect(proj.x, proj.z);
                        SoundManager.playHit();
                    }

                    // Chain lightning effect
                    if (proj.chainTargets > 0) {
                        let lastX = proj.x;
                        let lastZ = proj.z;
                        const hitEnemies = [proj.targetEnemy];

                        for (let c = 0; c < proj.chainTargets; c++) {
                            // Find nearest unhit enemy
                            let nearestChain = null;
                            let nearestChainDist = 15; // Max chain range

                            game.enemies.forEach(enemy => {
                                if (hitEnemies.includes(enemy)) return;
                                const cdx = enemy.x - lastX;
                                const cdz = enemy.z - lastZ;
                                const cDist = Math.sqrt(cdx * cdx + cdz * cdz);
                                if (cDist < nearestChainDist) {
                                    nearestChainDist = cDist;
                                    nearestChain = enemy;
                                }
                            });

                            if (nearestChain) {
                                // Chain damage (70% of original per jump)
                                const chainDamage = Math.floor(proj.damage * Math.pow(0.7, c + 1));
                                nearestChain.hp -= chainDamage;
                                hitEnemies.push(nearestChain);

                                // Chain lightning visual
                                createChainEffect(lastX, lastZ, nearestChain.x, nearestChain.z);
                                SoundManager.playChain();
                                lastX = nearestChain.x;
                                lastZ = nearestChain.z;
                            }
                        }
                    }

                    scene.remove(proj.mesh);
                    game.projectiles.splice(i, 1);
                } else {
                    // Move projectile
                    const moveAmount = proj.speed * dt;
                    proj.x += (dx / dist) * moveAmount;
                    proj.y += (dy / dist) * moveAmount;
                    proj.z += (dz / dist) * moveAmount;
                    proj.mesh.position.set(proj.x, proj.y, proj.z);
                }
            }
        }

        // AOE explosion effect
        function createAoeEffect(x, z, radius, beastType) {
            const color = beastType === 'hydra' ? 0x9932CC : 0xFFFF00; // Purple or yellow
            const geo = new THREE.RingGeometry(0.5, radius, 32);
            const mat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(geo, mat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.set(x, 0.5, z);
            scene.add(ring);

            // Fade out and remove
            let opacity = 0.6;
            const fadeInterval = setInterval(() => {
                opacity -= 0.15;
                ring.material.opacity = opacity;
                if (opacity <= 0) {
                    clearInterval(fadeInterval);
                    scene.remove(ring);
                }
            }, 50);
        }

        // Chain lightning visual effect
        function createChainEffect(x1, z1, x2, z2) {
            const points = [
                new THREE.Vector3(x1, 2, z1),
                new THREE.Vector3((x1 + x2) / 2, 2.5, (z1 + z2) / 2), // Slight arc
                new THREE.Vector3(x2, 2, z2)
            ];
            const curve = new THREE.QuadraticBezierCurve3(points[0], points[1], points[2]);
            const geometry = new THREE.TubeGeometry(curve, 8, 0.1, 8, false);
            const material = new THREE.MeshBasicMaterial({ color: 0x00FFFF, transparent: true, opacity: 0.9 });
            const lightning = new THREE.Mesh(geometry, material);
            scene.add(lightning);

            // Quick fade
            setTimeout(() => {
                let opacity = 0.9;
                const fadeInterval = setInterval(() => {
                    opacity -= 0.3;
                    lightning.material.opacity = opacity;
                    if (opacity <= 0) {
                        clearInterval(fadeInterval);
                        scene.remove(lightning);
                    }
                }, 30);
            }, 100);
        }

        function createHitEffect(x, z) {
            const geo = new THREE.RingGeometry(0.5, 1.5, 16);
            const mat = new THREE.MeshBasicMaterial({
                color: 0xFFFF00,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(geo, mat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.set(x, 0.5, z);
            scene.add(ring);

            // Animate and remove
            let scale = 1;
            const animate = () => {
                scale += 0.3;
                ring.scale.set(scale, scale, scale);
                mat.opacity -= 0.15;
                if (mat.opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(ring);
                }
            };
            animate();
        }

        function updateEnemies(dt) {
            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const enemy = game.enemies[i];

                // Move towards center/player
                const targetX = player.x;
                const targetZ = player.z;
                const dx = targetX - enemy.x;
                const dz = targetZ - enemy.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist > 2) {
                    // Calculate new position
                    let newX = enemy.x + (dx / dist) * enemy.speed * dt;
                    let newZ = enemy.z + (dz / dist) * enemy.speed * dt;

                    // Check fence collision - CIRCULAR boundary
                    const radius = CONFIG.fenceBoundary;
                    const newDist = Math.sqrt(newX * newX + newZ * newZ);
                    const currentDist = Math.sqrt(enemy.x * enemy.x + enemy.z * enemy.z);
                    const isInsideFence = newDist < radius;
                    const currentlyOutsideFence = currentDist >= radius;

                    // Fence is INDESTRUCTIBLE - enemies blocked at circular boundary
                    if (isInsideFence) {
                        // Stop at fence (cannot pass through)
                        enemy.attackingFence = true;
                        game.fenceUnderAttack = true;

                        // Clamp position to fence boundary circle (stop at edge)
                        const clampDist = Math.max(currentDist, radius);
                        const angle = Math.atan2(enemy.z, enemy.x);
                        enemy.x = Math.cos(angle) * clampDist;
                        enemy.z = Math.sin(angle) * clampDist;
                        enemy.mesh.position.set(enemy.x, 0, enemy.z);
                    } else {
                        // Normal movement outside fence
                        enemy.attackingFence = false;
                        enemy.x = newX;
                        enemy.z = newZ;
                        enemy.mesh.position.set(enemy.x, 0, enemy.z);
                    }
                }

                // Check if dead
                if (enemy.hp <= 0) {
                    scene.remove(enemy.mesh);

                    // Drop loot
                    spawnLoot(enemy.x + (Math.random() - 0.5) * 2, enemy.z + (Math.random() - 0.5) * 2, 'coin');
                    if (Math.random() < 0.3) {
                        spawnLoot(enemy.x + (Math.random() - 0.5) * 2, enemy.z + (Math.random() - 0.5) * 2, 'meat');
                    }

                    // Check if boss
                    if (enemy.type === 'boss') {
                        game.bossDefeated = true;
                        SoundManager.playVictory();
                        showPrompt('ğŸ† BOSSè¢«å‡»è´¥ï¼èƒœåˆ©ï¼');
                        advanceStep(); // Step 13 -> 14
                        // Show victory screen after a short delay
                        setTimeout(() => {
                            console.log('Showing victory screen, current step:', game.step);
                            showVictory();
                        }, 2000);
                    }

                    game.enemies.splice(i, 1);
                }

                // Animate
                enemy.mesh.rotation.y += dt * 2;
            }
        }

        function updateWorkers(dt) {
            // First, collect all currently claimed loot by workers
            const claimedLoot = new Set();
            game.workers.forEach(w => {
                if (w.targetLoot && game.loot.includes(w.targetLoot)) {
                    claimedLoot.add(w.targetLoot);
                }
            });

            game.workers.forEach(worker => {
                // Find new target if current one is invalid or collected
                if (!worker.targetLoot || !game.loot.includes(worker.targetLoot)) {
                    worker.targetLoot = null; // Clear invalid target

                    let nearest = null;
                    let nearestDist = Infinity;

                    game.loot.forEach(loot => {
                        // Skip loot already claimed by ANOTHER worker
                        if (claimedLoot.has(loot)) return;

                        const dx = worker.x - loot.x;
                        const dz = worker.z - loot.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = loot;
                        }
                    });

                    if (nearest) {
                        worker.targetLoot = nearest;
                        claimedLoot.add(nearest); // Mark as claimed
                    }
                }

                // Move towards target loot
                if (worker.targetLoot) {
                    const dx = worker.targetLoot.x - worker.x;
                    const dz = worker.targetLoot.z - worker.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist > 0.5) {
                        // Move towards loot
                        worker.x += (dx / dist) * 10 * dt; // Increased speed from 8 to 10
                        worker.z += (dz / dist) * 10 * dt;
                        worker.mesh.position.set(worker.x, 0, worker.z);
                    } else {
                        // Collect the loot
                        if (worker.targetLoot.type === 'meat') game.meat += 2;
                        else if (worker.targetLoot.type === 'coin') game.coins += 15;

                        scene.remove(worker.targetLoot.mesh);
                        const idx = game.loot.indexOf(worker.targetLoot);
                        if (idx >= 0) game.loot.splice(idx, 1);

                        claimedLoot.delete(worker.targetLoot);
                        worker.targetLoot = null; // Clear so worker finds new target next frame
                        updateHUD();
                        updateBeastPanel(); // Refresh button states when resources change
                    }
                } else {
                    // No loot to collect - return to patrol/idle near worker hut
                    // Move towards worker hut area (15, -10)
                    const homeX = 15 + (game.workers.indexOf(worker) - 1.5) * 3; // Spread workers
                    const homeZ = -10;
                    const dx = homeX - worker.x;
                    const dz = homeZ - worker.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist > 2) {
                        worker.x += (dx / dist) * 6 * dt;
                        worker.z += (dz / dist) * 6 * dt;
                        worker.mesh.position.set(worker.x, 0, worker.z);
                    }
                }
            });
        }

        // ==================== INPUT HANDLING ====================
        function initInput() {
            // Keyboard
            document.addEventListener('keydown', e => {
                if (e.key.toLowerCase() === 'w') keys.w = true;
                if (e.key.toLowerCase() === 'a') keys.a = true;
                if (e.key.toLowerCase() === 's') keys.s = true;
                if (e.key.toLowerCase() === 'd') keys.d = true;

                startGame();
            });

            document.addEventListener('keyup', e => {
                if (e.key.toLowerCase() === 'w') keys.w = false;
                if (e.key.toLowerCase() === 'a') keys.a = false;
                if (e.key.toLowerCase() === 's') keys.s = false;
                if (e.key.toLowerCase() === 'd') keys.d = false;
            });

            // Tutorial Joystick (Static, right bottom)
            tutorialJoystick = nipplejs.create({
                zone: document.getElementById('joystickZone'),
                mode: 'static',
                position: { right: '75px', bottom: '75px' },
                color: '#4CAF50',
                size: 120
            });

            tutorialJoystick.on('move', (evt, data) => {
                const force = Math.min(data.force, 1);
                const angle = data.angle.radian;
                joystickVector.x = Math.cos(angle) * force;
                joystickVector.y = Math.sin(angle) * force;

                startGame();
            });

            tutorialJoystick.on('end', () => {
                joystickVector.x = 0;
                joystickVector.y = 0;
            });

            // Dynamic Joystick (follows touch, for gameplay) - attached to canvas
            dynamicJoystick = nipplejs.create({
                zone: renderer.domElement,
                mode: 'dynamic',
                color: '#4CAF50',
                size: 120,
                restOpacity: 0.8
            });

            dynamicJoystick.on('start', () => {
                startGame();
            });

            dynamicJoystick.on('move', (evt, data) => {
                const force = Math.min(data.force, 1);
                const angle = data.angle.radian;
                joystickVector.x = Math.cos(angle) * force;
                joystickVector.y = Math.sin(angle) * force;
            });

            dynamicJoystick.on('end', () => {
                joystickVector.x = 0;
                joystickVector.y = 0;
            });

            // Dynamic joystick starts hidden (will show on game start)
            // No need to hide initially as it's created dynamically

            // Tutorial click
            document.getElementById('tutorialOverlay').addEventListener('click', startGame);
        }

        function startGame() {
            if (game.started) return;
            game.started = true;

            // Initialize sound system
            SoundManager.init();

            document.getElementById('tutorialOverlay').style.display = 'none';

            // Switch from tutorial joystick to dynamic joystick
            document.getElementById('joystickZone').style.display = 'none';
            // Dynamic joystick will appear automatically on first touch
        }

        // ==================== WINDOW RESIZE ====================
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 18;

            camera.left = -viewSize * aspect;
            camera.right = viewSize * aspect;
            camera.top = viewSize;
            camera.bottom = -viewSize;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== GAME LOOP ====================
        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            update(dt);

            renderer.render(scene, camera);
        }

        // ==================== INIT ====================
        function init() {
            initThreeJS();
            initInput();
            updateHUD();
            updateBeastPanel();
            animate();
        }

        init();
    </script>
</body>

</html>