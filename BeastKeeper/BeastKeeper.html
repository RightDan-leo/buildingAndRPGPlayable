<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å·¨å…½æ”¶å®¹æ‰€ - BeastKeeper</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            touch-action: none;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: #1a1a2e;
        }

        #gameCanvas {
            display: block;
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .resource-bar {
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 15px;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .resource-bar .icon {
            font-size: 20px;
        }

        .resource-bar .value {
            font-weight: bold;
            color: #ffd700;
        }

        /* Joystick */
        #joystickZone {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            z-index: 200;
        }

        /* Tutorial Overlay */
        #tutorialOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 500;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        #tutorialOverlay h1 {
            font-size: 36px;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px #000;
        }

        #tutorialOverlay .hand {
            font-size: 80px;
            animation: handMove 1.5s infinite;
        }

        @keyframes handMove {

            0%,
            100% {
                transform: translate(0, 0);
            }

            50% {
                transform: translate(30px, 30px);
            }
        }

        #tutorialOverlay p {
            font-size: 20px;
            margin-top: 20px;
            opacity: 0.8;
        }

        /* Prompts */
        #promptBox {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 60, 0.9));
            padding: 15px 30px;
            border-radius: 15px;
            border: 2px solid #4CAF50;
            color: white;
            font-size: 20px;
            z-index: 300;
            text-align: center;
            display: none;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 10px #4CAF50;
            }

            50% {
                box-shadow: 0 0 25px #4CAF50;
            }
        }

        /* Beast Panel */
        #beastPanel {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .beast-card {
            background: rgba(0, 0, 0, 0.85);
            padding: 10px 15px;
            border-radius: 12px;
            border: 2px solid #666;
            color: white;
            min-width: 160px;
        }

        .beast-card.active {
            border-color: #4CAF50;
        }

        .beast-card .name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .beast-card .stage {
            font-size: 12px;
            color: #aaa;
        }

        .beast-card .progress-bar {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }

        .beast-card .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s;
        }

        .beast-card .feed-btn {
            margin-top: 8px;
            padding: 6px 12px;
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            border: none;
            border-radius: 15px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .beast-card .feed-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.6);
        }

        .beast-card .feed-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        /* Victory Screen */
        #victoryScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            z-index: 1000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        #victoryScreen h1 {
            font-size: 48px;
            color: #ffd700;
            text-shadow: 3px 3px 6px #000;
            margin-bottom: 20px;
        }

        #victoryScreen p {
            font-size: 20px;
            margin-bottom: 40px;
            opacity: 0.9;
        }

        #victoryScreen .btn {
            padding: 15px 40px;
            font-size: 22px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s;
        }

        #victoryScreen .btn:hover {
            transform: scale(1.05);
        }

        #victoryScreen .btn-download {
            background: linear-gradient(135deg, #f39c12, #e74c3c);
            color: white;
        }

        #victoryScreen .btn-restart {
            background: #555;
            color: white;
        }

        /* Controls hint */
        #controlsHint {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border-radius: 20px;
            color: #aaa;
            font-size: 14px;
            z-index: 50;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <div class="resource-bar">
            <span class="icon">ğŸ¥©</span>
            <span>è‚‰å—:</span>
            <span class="value" id="meatCount">15</span>
        </div>
        <div class="resource-bar">
            <span class="icon">ğŸª™</span>
            <span>é‡‘å¸:</span>
            <span class="value" id="coinCount">0</span>
        </div>
    </div>

    <!-- Beast Panel -->
    <div id="beastPanel"></div>

    <!-- Prompt Box -->
    <div id="promptBox"></div>

    <!-- Joystick Zone -->
    <div id="joystickZone"></div>

    <!-- Tutorial Overlay -->
    <div id="tutorialOverlay">
        <h1>ğŸ‰ å·¨å…½æ”¶å®¹æ‰€ ğŸ‰</h1>
        <div class="hand">ğŸ‘†</div>
        <p>æ‹–åŠ¨æ‘‡æ†æˆ–ä½¿ç”¨ WASD ç§»åŠ¨</p>
        <p style="opacity:0.5; font-size:14px;">ç‚¹å‡»ä»»æ„ä½ç½®å¼€å§‹</p>
    </div>

    <!-- Victory Screen -->
    <div id="victoryScreen">
        <h1>ğŸ† èƒœåˆ©ï¼ğŸ†</h1>
        <p>æ­å–œä½ æˆåŠŸç»è¥äº†å·¨å…½æ”¶å®¹æ‰€ï¼</p>
        <button class="btn btn-download" onclick="window.open('https://example.com/download')">
            ğŸ“² ç«‹å³ä¸‹è½½å®Œæ•´ç‰ˆ
        </button>
        <button class="btn btn-restart" onclick="location.reload()">
            ğŸ”„ é‡æ–°å¼€å§‹
        </button>
    </div>

    <!-- Controls Hint -->
    <div id="controlsHint">WASD æˆ– æ‹–åŠ¨æ‘‡æ†ç§»åŠ¨</div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

    <script>
        // ==================== GAME CONFIG ====================
        const CONFIG = {
            // Resources - enough for first feed
            startingMeat: 15,
            startingCoins: 0,

            // Beast feeding - one feed = full progress
            feedCost: 10,
            feedProgressPerFeed: 100, // One feed fills bar completely

            // Buildings
            meatFactoryCost: 50,
            workerHutCost: 80,
            upgradeMeatFactoryCost: 100,
            meatProductionRate: 2, // per second
            meatProductionRateUpgraded: 5,

            // Combat - increased ranges and speeds
            enemySpawnInterval: 3, // seconds
            beastAttackRange: 25, // INCREASED for ranged attacks
            beastAttackDamage: { baby: 0, healthy: 15, evolved: 60 },
            beastMoveSpeed: 12, // Beasts move towards enemies
            enemySpeed: 8, // Faster enemies
            bossHp: 500,
            bossSpawnDelay: 5,

            // Player - faster movement
            playerSpeed: 25,
            collectRange: 3
        };

        // ==================== GAME STATE ====================
        const game = {
            started: false,
            step: 1,
            meat: CONFIG.startingMeat,
            coins: CONFIG.startingCoins,

            beasts: [],
            buildings: [],
            enemies: [],
            loot: [],
            workers: [],
            projectiles: [], // Beast ranged attacks
            buildingLabels: [], // 3D building info labels

            // Flags
            hydraSpawned: false,
            thunderbirdSpawned: false,
            meatFactoryBuilt: false,
            workerHutBuilt: false,
            meatFactoryUpgraded: false,
            bossSpawned: false,
            bossDefeated: false,

            // Timer
            lastTime: 0,
            meatProductionTimer: 0,
            enemySpawnTimer: 0
        };

        // ==================== THREE.JS SETUP ====================
        let scene, camera, renderer;
        let player, playerMesh;
        let groundMesh;
        const clock = new THREE.Clock();

        // Input
        const keys = { w: false, a: false, s: false, d: false };
        let joystickVector = { x: 0, y: 0 };
        let joystick = null;

        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x228B22);
            scene.fog = new THREE.Fog(0x228B22, 50, 150);

            // Camera (Orthographic for top-down)
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 40;
            camera = new THREE.OrthographicCamera(
                -viewSize * aspect, viewSize * aspect,
                viewSize, -viewSize,
                1, 1000
            );
            camera.position.set(0, 60, 40);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(30, 50, 30);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(200, 200);
            const groundMat = new THREE.MeshPhongMaterial({
                color: 0x3d8b40,
                side: THREE.DoubleSide
            });
            groundMesh = new THREE.Mesh(groundGeo, groundMat);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Sanctuary fence
            createSanctuaryArea();

            // Player
            createPlayer();

            // Spawn initial Hydra
            spawnInjuredHydra();

            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }

        function createSanctuaryArea() {
            // Fence posts around sanctuary
            const fenceMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const postGeo = new THREE.CylinderGeometry(0.3, 0.3, 3, 8);

            const fencePositions = [];
            for (let x = -25; x <= 25; x += 5) {
                fencePositions.push({ x, z: -25 });
                fencePositions.push({ x, z: 25 });
            }
            for (let z = -20; z <= 20; z += 5) {
                fencePositions.push({ x: -25, z });
                fencePositions.push({ x: 25, z });
            }

            fencePositions.forEach(pos => {
                const post = new THREE.Mesh(postGeo, fenceMat);
                post.position.set(pos.x, 1.5, pos.z);
                post.castShadow = true;
                scene.add(post);
            });

            // Beast pen area (darker grass)
            const penGeo = new THREE.PlaneGeometry(20, 15);
            const penMat = new THREE.MeshPhongMaterial({ color: 0x2d6a2e });
            const penMesh = new THREE.Mesh(penGeo, penMat);
            penMesh.rotation.x = -Math.PI / 2;
            penMesh.position.set(-10, 0.01, 10);
            scene.add(penMesh);

            // Building area markers
            createBuildingSpot(15, 10, 'meat_factory');
            createBuildingSpot(15, -5, 'worker_hut');

            // Create upgrade label (initially hidden, shown by updateBuildingLabels at step 9)
            showUpgradeLabel(15, 10);
        }

        function createBuildingSpot(x, z, type) {
            const spotGeo = new THREE.PlaneGeometry(8, 8);
            const spotMat = new THREE.MeshPhongMaterial({
                color: 0x555555,
                transparent: true,
                opacity: 0.5
            });
            const spot = new THREE.Mesh(spotGeo, spotMat);
            spot.rotation.x = -Math.PI / 2;
            spot.position.set(x, 0.02, z);
            spot.userData = { type: type, isSpot: true };
            scene.add(spot);

            // Create building info label
            const labelGroup = new THREE.Group();

            // Info text based on type
            let labelInfo;
            if (type === 'meat_factory') {
                labelInfo = {
                    name: 'ğŸ­ é€ è‚‰å‚',
                    desc: 'è‡ªåŠ¨äº§è‚‰',
                    cost: CONFIG.meatFactoryCost
                };
            } else if (type === 'worker_hut') {
                labelInfo = {
                    name: 'ğŸ  å·¥äººå°å±‹',
                    desc: '4å·¥äººè‡ªåŠ¨æ”¶é›†',
                    cost: CONFIG.workerHutCost
                };
            }

            // Create floating billboard using canvas texture
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.roundRect(0, 0, 256, 128, 10);
            ctx.fill();
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(labelInfo.name, 128, 35);

            ctx.font = '20px Arial';
            ctx.fillStyle = '#aaffaa';
            ctx.fillText(labelInfo.desc, 128, 65);

            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#ffd700';
            ctx.fillText('ğŸ’° ' + labelInfo.cost + ' é‡‘å¸', 128, 105);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(12, 6, 1);
            sprite.position.set(x, 8, z);
            sprite.userData = { type: type, isLabel: true };
            sprite.visible = false; // Start hidden, show via updateBuildingLabels
            scene.add(sprite);

            // Store reference for removal when building is built
            game.buildingLabels.push({ type, sprite, spot });

            return spot;
        }

        // Manage label visibility based on game step
        function updateBuildingLabels() {
            game.buildingLabels.forEach(label => {
                let shouldShow = false;

                switch (label.type) {
                    case 'meat_factory':
                        // Show meat factory label at step 4 (after enemies spawn, before building)
                        shouldShow = !game.meatFactoryBuilt && game.step >= 4;
                        break;
                    case 'worker_hut':
                        // Show worker hut label at step 8 (after thunderbird healthy)
                        shouldShow = !game.workerHutBuilt && game.step >= 8;
                        break;
                    case 'upgrade_meat_factory':
                        // Show upgrade label at step 9 (after worker hut built)
                        shouldShow = game.meatFactoryBuilt && !game.meatFactoryUpgraded && game.step >= 9;
                        break;
                }

                if (label.sprite) label.sprite.visible = shouldShow;
                if (label.spot) label.spot.visible = shouldShow || game.meatFactoryBuilt || game.workerHutBuilt;
            });
        }

        function createPlayer() {
            // Simple character: body + head
            const group = new THREE.Group();

            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.8, 1, 2, 8);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0x9370DB }); // Purple
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1;
            body.castShadow = true;
            group.add(body);

            // Head
            const headGeo = new THREE.SphereGeometry(0.6, 16, 16);
            const headMat = new THREE.MeshPhongMaterial({ color: 0xFFE4C4 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 2.5;
            head.castShadow = true;
            group.add(head);

            // Hair (blonde)
            const hairGeo = new THREE.SphereGeometry(0.65, 16, 16);
            const hairMat = new THREE.MeshPhongMaterial({ color: 0xFFD700 });
            const hair = new THREE.Mesh(hairGeo, hairMat);
            hair.position.set(0, 2.7, -0.1);
            hair.scale.set(1, 0.8, 1);
            group.add(hair);

            group.position.set(0, 0, 0);
            scene.add(group);

            playerMesh = group;
            player = { x: 0, z: 0, mesh: group };
        }

        // ==================== BEAST SYSTEM ====================
        function createBeastMesh(type, stage) {
            const group = new THREE.Group();

            if (type === 'hydra') {
                const scale = stage === 'evolved' ? 3 : (stage === 'healthy' ? 1.5 : 1);
                const color = stage === 'baby' ? 0x90EE90 : 0x228B22;

                // Body
                const bodyGeo = new THREE.SphereGeometry(1.5 * scale, 16, 16);
                const bodyMat = new THREE.MeshPhongMaterial({ color });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.scale.set(1, 0.6, 1.2);
                body.position.y = 1 * scale;
                body.castShadow = true;
                group.add(body);

                // Heads (1 for baby, 3 for healthy, 9 for evolved)
                const headCount = stage === 'evolved' ? 9 : (stage === 'healthy' ? 3 : 1);
                const headGeo = new THREE.SphereGeometry(0.5 * scale, 12, 12);
                const headMat = new THREE.MeshPhongMaterial({ color });

                for (let i = 0; i < headCount; i++) {
                    const head = new THREE.Mesh(headGeo, headMat);
                    const angle = (i / headCount) * Math.PI - Math.PI / 2;
                    head.position.set(
                        Math.sin(angle) * 1.5 * scale,
                        2 * scale + Math.abs(Math.sin(angle)) * 0.5 * scale,
                        Math.cos(angle) * 0.5 * scale - 1 * scale
                    );
                    head.castShadow = true;
                    group.add(head);

                    // Eyes
                    const eyeGeo = new THREE.SphereGeometry(0.15 * scale, 8, 8);
                    const eyeMat = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
                    const eye = new THREE.Mesh(eyeGeo, eyeMat);
                    eye.position.copy(head.position);
                    eye.position.z += 0.4 * scale;
                    eye.position.y += 0.1 * scale;
                    group.add(eye);
                }

                // Injured indicator
                if (stage === 'baby') {
                    const bandageGeo = new THREE.BoxGeometry(0.8, 0.2, 0.1);
                    const bandageMat = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
                    const bandage = new THREE.Mesh(bandageGeo, bandageMat);
                    bandage.position.set(0, 1.5, 1.2);
                    group.add(bandage);

                    const crossGeo = new THREE.BoxGeometry(0.3, 0.1, 0.05);
                    const crossMat = new THREE.MeshPhongMaterial({ color: 0xFF0000 });
                    const cross1 = new THREE.Mesh(crossGeo, crossMat);
                    cross1.position.set(0, 1.5, 1.25);
                    group.add(cross1);
                }
            } else if (type === 'thunderbird') {
                const scale = stage === 'evolved' ? 3 : (stage === 'healthy' ? 1.5 : 1);
                const color = stage === 'baby' ? 0x87CEEB : 0x4169E1;

                // Body
                const bodyGeo = new THREE.SphereGeometry(1 * scale, 16, 16);
                const bodyMat = new THREE.MeshPhongMaterial({ color });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.scale.set(1, 0.8, 1.5);
                body.position.y = 2 * scale;
                body.castShadow = true;
                group.add(body);

                // Head
                const headGeo = new THREE.SphereGeometry(0.6 * scale, 12, 12);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.position.set(0, 2.5 * scale, -0.8 * scale);
                head.castShadow = true;
                group.add(head);

                // Beak
                const beakGeo = new THREE.ConeGeometry(0.2 * scale, 0.5 * scale, 8);
                const beakMat = new THREE.MeshPhongMaterial({ color: 0xFFA500 });
                const beak = new THREE.Mesh(beakGeo, beakMat);
                beak.rotation.x = Math.PI / 2;
                beak.position.set(0, 2.4 * scale, -1.5 * scale);
                group.add(beak);

                // Wings
                const wingGeo = new THREE.BoxGeometry(3 * scale, 0.2 * scale, 1.5 * scale);
                const wingMat = new THREE.MeshPhongMaterial({ color });

                const leftWing = new THREE.Mesh(wingGeo, wingMat);
                leftWing.position.set(-2 * scale, 2 * scale, 0);
                leftWing.rotation.z = 0.3;
                leftWing.castShadow = true;
                group.add(leftWing);

                const rightWing = new THREE.Mesh(wingGeo, wingMat);
                rightWing.position.set(2 * scale, 2 * scale, 0);
                rightWing.rotation.z = -0.3;
                rightWing.castShadow = true;
                group.add(rightWing);

                // Lightning effect for evolved
                if (stage === 'evolved') {
                    const lightningMat = new THREE.MeshBasicMaterial({
                        color: 0xFFFF00,
                        transparent: true,
                        opacity: 0.8
                    });
                    for (let i = 0; i < 5; i++) {
                        const boltGeo = new THREE.CylinderGeometry(0.1, 0.1, 2, 4);
                        const bolt = new THREE.Mesh(boltGeo, lightningMat);
                        bolt.position.set(
                            (Math.random() - 0.5) * 6,
                            1 + Math.random() * 3,
                            (Math.random() - 0.5) * 4
                        );
                        bolt.rotation.set(Math.random(), Math.random(), Math.random());
                        group.add(bolt);
                    }
                }

                // Injured indicator
                if (stage === 'baby') {
                    const bandageGeo = new THREE.BoxGeometry(0.6, 0.15, 0.08);
                    const bandageMat = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
                    const bandage = new THREE.Mesh(bandageGeo, bandageMat);
                    bandage.position.set(0, 2.8, -0.8);
                    group.add(bandage);
                }
            }

            return group;
        }

        function spawnInjuredHydra() {
            if (game.hydraSpawned) return;
            game.hydraSpawned = true;

            const mesh = createBeastMesh('hydra', 'baby');
            mesh.position.set(-10, 0, 15);
            scene.add(mesh);

            game.beasts.push({
                type: 'hydra',
                stage: 'baby',
                feedProgress: 0,
                mesh: mesh,
                x: -10,
                z: 15,
                captured: false,
                attackCooldown: 0
            });

            showPrompt('ğŸ’” å‘ç°å—ä¼¤çš„å¹¼å¹´ä¹å¤´è›‡ï¼é è¿‘æ•è·ï¼');
            updateBeastPanel();
        }

        function spawnThunderbird() {
            if (game.thunderbirdSpawned) return;
            game.thunderbirdSpawned = true;

            const mesh = createBeastMesh('thunderbird', 'baby');
            mesh.position.set(0, 0, -30);
            scene.add(mesh);

            game.beasts.push({
                type: 'thunderbird',
                stage: 'baby',
                feedProgress: 0,
                mesh: mesh,
                x: 0,
                z: -30,
                captured: false,
                attackCooldown: 0
            });

            showPrompt('ğŸ¦… åŸå¤–å‘ç°å—ä¼¤çš„é›·é¹é¸Ÿï¼å‰å¾€æ•è·ï¼');
            updateBeastPanel();
        }

        function captureBeast(beast) {
            if (beast.captured) return;
            beast.captured = true;

            // Move to pen
            const penX = -10 + game.beasts.filter(b => b.captured).length * 5;
            beast.x = penX;
            beast.z = 10;
            beast.mesh.position.set(penX, 0, 10);

            showPrompt(`âœ… æˆåŠŸæ•è·${beast.type === 'hydra' ? 'ä¹å¤´è›‡' : 'é›·é¹é¸Ÿ'}ï¼ç”¨è‚‰å—å–‚å…»å®ƒï¼`);
            updateBeastPanel();
            advanceStep();
        }

        function feedBeast(beast) {
            if (game.meat < CONFIG.feedCost) {
                showPrompt('âŒ è‚‰å—ä¸è¶³ï¼éœ€è¦ ' + CONFIG.feedCost + ' è‚‰å—');
                return;
            }

            game.meat -= CONFIG.feedCost;
            beast.feedProgress += CONFIG.feedProgressPerFeed;

            if (beast.feedProgress >= 100) {
                beast.feedProgress = 0;
                evolveBeast(beast);
            } else {
                showPrompt(`ğŸ¥© å–‚é£ŸæˆåŠŸï¼è¿›åº¦: ${beast.feedProgress}%`);
            }

            updateHUD();
            updateBeastPanel();
        }

        function evolveBeast(beast) {
            // Remove old mesh
            scene.remove(beast.mesh);

            const wasStage = beast.stage;

            if (beast.stage === 'baby') {
                beast.stage = 'healthy';
                showPrompt(`ğŸ’š ${beast.type === 'hydra' ? 'ä¹å¤´è›‡' : 'é›·é¹é¸Ÿ'}æ¢å¤å¥åº·ï¼å¯ä»¥æˆ˜æ–—äº†ï¼`);
            } else if (beast.stage === 'healthy') {
                beast.stage = 'evolved';
                showPrompt(`âš¡ ${beast.type === 'hydra' ? 'ä¹å¤´è›‡' : 'é›·é¹é¸Ÿ'}è¿›åŒ–æˆå·¨å‹å½¢æ€ï¼æˆ˜åŠ›æš´å¢ï¼`);
            }

            // Create new mesh
            beast.mesh = createBeastMesh(beast.type, beast.stage);
            beast.mesh.position.set(beast.x, 0, beast.z);
            scene.add(beast.mesh);

            updateBeastPanel();

            // Step progression based on which beast evolved
            if (beast.type === 'hydra') {
                if (wasStage === 'baby' && beast.stage === 'healthy') {
                    // Step 3: Hydra healthy, then auto-trigger step 4 (enemies)
                    advanceStep(); // -> step 3
                    setTimeout(() => advanceStep(), 1000); // -> step 4 (enemies spawn)
                } else if (wasStage === 'healthy' && beast.stage === 'evolved') {
                    // Step 11: Hydra evolved to giant
                    if (game.step < 11) game.step = 10;
                    advanceStep(); // -> step 11
                }
            } else if (beast.type === 'thunderbird') {
                if (wasStage === 'baby' && beast.stage === 'healthy') {
                    // Step 8: Thunderbird healthy
                    if (game.step < 8) game.step = 7;
                    advanceStep(); // -> step 8
                } else if (wasStage === 'healthy' && beast.stage === 'evolved') {
                    // Step 12: Thunderbird evolved, then step 13 (boss)
                    if (game.step < 12) game.step = 11;
                    advanceStep(); // -> step 12
                    setTimeout(() => advanceStep(), 2000); // -> step 13 (boss spawns)
                }
            }
        }

        // ==================== BUILDING SYSTEM ====================
        function createBuilding(type, x, z) {
            const group = new THREE.Group();

            if (type === 'meat_factory') {
                // Factory building
                const baseGeo = new THREE.BoxGeometry(6, 4, 6);
                const baseMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = 2;
                base.castShadow = true;
                group.add(base);

                // Chimney
                const chimneyGeo = new THREE.CylinderGeometry(0.5, 0.5, 3, 8);
                const chimneyMat = new THREE.MeshPhongMaterial({ color: 0x696969 });
                const chimney = new THREE.Mesh(chimneyGeo, chimneyMat);
                chimney.position.set(2, 5.5, 0);
                chimney.castShadow = true;
                group.add(chimney);

                // Sign
                const signGeo = new THREE.BoxGeometry(2, 1, 0.1);
                const signMat = new THREE.MeshPhongMaterial({ color: 0xFF6347 });
                const sign = new THREE.Mesh(signGeo, signMat);
                sign.position.set(0, 4.5, 3.1);
                group.add(sign);
            } else if (type === 'worker_hut') {
                // Hut building
                const baseGeo = new THREE.BoxGeometry(5, 3, 5);
                const baseMat = new THREE.MeshPhongMaterial({ color: 0xDEB887 });
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = 1.5;
                base.castShadow = true;
                group.add(base);

                // Roof
                const roofGeo = new THREE.ConeGeometry(4, 2, 4);
                const roofMat = new THREE.MeshPhongMaterial({ color: 0x8B0000 });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.y = 4;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                group.add(roof);
            }

            group.position.set(x, 0, z);
            scene.add(group);

            return {
                type,
                x,
                z,
                mesh: group,
                level: 1
            };
        }

        function removeBuildingLabel(type) {
            const idx = game.buildingLabels.findIndex(l => l.type === type);
            if (idx >= 0) {
                const label = game.buildingLabels[idx];
                scene.remove(label.sprite);
                scene.remove(label.spot);
                game.buildingLabels.splice(idx, 1);
            }
        }

        function showUpgradeLabel(x, z) {
            // Create upgrade label
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.roundRect(0, 0, 256, 128, 10);
            ctx.fill();
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 26px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('â¬†ï¸ å‡çº§é€ è‚‰å‚', 128, 40);

            ctx.font = '18px Arial';
            ctx.fillStyle = '#aaffaa';
            ctx.fillText('äº§å‡ºæ•ˆç‡ç¿»å€', 128, 70);

            ctx.font = 'bold 22px Arial';
            ctx.fillStyle = '#ffd700';
            ctx.fillText('ğŸ’° ' + CONFIG.upgradeMeatFactoryCost + ' é‡‘å¸', 128, 105);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(12, 6, 1);
            sprite.position.set(x, 10, z);
            sprite.userData = { type: 'upgrade_meat_factory', isLabel: true };
            sprite.visible = false; // Start hidden, managed by updateBuildingLabels
            scene.add(sprite);
            game.buildingLabels.push({ type: 'upgrade_meat_factory', sprite, spot: null });
        }

        function buildMeatFactory() {
            if (game.meatFactoryBuilt) return;
            if (game.coins < CONFIG.meatFactoryCost) {
                showPrompt('âŒ é‡‘å¸ä¸è¶³ï¼éœ€è¦ ' + CONFIG.meatFactoryCost + ' é‡‘å¸');
                return;
            }

            game.coins -= CONFIG.meatFactoryCost;
            game.meatFactoryBuilt = true;

            // Remove construction label
            removeBuildingLabel('meat_factory');

            const building = createBuilding('meat_factory', 15, 10);
            game.buildings.push(building);

            showPrompt('ğŸ­ é€ è‚‰å‚å»ºæˆï¼è‡ªåŠ¨ç”Ÿäº§è‚‰å—ï¼');
            updateHUD();

            // Advance from step 4 to step 5, then immediately to step 6 (thunderbird)
            game.step = 5; // Complete building step
            advanceStep(); // Move to step 6, triggers thunderbird spawn
        }

        function buildWorkerHut() {
            if (game.workerHutBuilt) return;
            if (game.coins < CONFIG.workerHutCost) {
                showPrompt('âŒ é‡‘å¸ä¸è¶³ï¼éœ€è¦ ' + CONFIG.workerHutCost + ' é‡‘å¸');
                return;
            }

            game.coins -= CONFIG.workerHutCost;
            game.workerHutBuilt = true;

            // Remove construction label
            removeBuildingLabel('worker_hut');

            const building = createBuilding('worker_hut', 15, -5);
            game.buildings.push(building);

            // Spawn workers
            for (let i = 0; i < 4; i++) {
                spawnWorker(15 + (i - 1.5) * 2, -5);
            }

            showPrompt('ğŸ  å·¥äººå°å±‹å»ºæˆï¼4ä¸ªå·¥äººè‡ªåŠ¨æ”¶é›†èµ„æºï¼');
            updateHUD();

            // Advance from step 8 to step 9
            game.step = 8;
            advanceStep(); // Move to step 9
        }

        function upgradeMeatFactory() {
            if (game.meatFactoryUpgraded) return;
            if (game.coins < CONFIG.upgradeMeatFactoryCost) {
                showPrompt('âŒ é‡‘å¸ä¸è¶³ï¼éœ€è¦ ' + CONFIG.upgradeMeatFactoryCost + ' é‡‘å¸');
                return;
            }

            game.coins -= CONFIG.upgradeMeatFactoryCost;
            game.meatFactoryUpgraded = true;

            // Remove upgrade label
            removeBuildingLabel('upgrade_meat_factory');

            showPrompt('â¬†ï¸ é€ è‚‰å‚å‡çº§ï¼äº§å‡ºæ•ˆç‡å¤§å¹…æå‡ï¼');
            updateHUD();

            // Advance from step 9 to step 10
            game.step = 9;
            advanceStep(); // Move to step 10
        }

        function spawnWorker(x, z) {
            const group = new THREE.Group();

            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.4, 0.5, 1.2, 8);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0x4682B4 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.6;
            body.castShadow = true;
            group.add(body);

            // Head
            const headGeo = new THREE.SphereGeometry(0.35, 12, 12);
            const headMat = new THREE.MeshPhongMaterial({ color: 0xFFE4C4 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.5;
            head.castShadow = true;
            group.add(head);

            group.position.set(x, 0, z);
            scene.add(group);

            game.workers.push({
                mesh: group,
                x,
                z,
                targetLoot: null
            });
        }

        // ==================== ENEMY SYSTEM ====================
        function createEnemyMesh(type) {
            const group = new THREE.Group();

            if (type === 'dark_spirit') {
                // Dark ghostly body
                const bodyGeo = new THREE.SphereGeometry(1, 12, 12);
                const bodyMat = new THREE.MeshPhongMaterial({
                    color: 0x4B0082,
                    transparent: true,
                    opacity: 0.8
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.scale.set(1, 1.3, 1);
                body.position.y = 1.5;
                body.castShadow = true;
                group.add(body);

                // Glowing eyes
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                const eyeGeo = new THREE.SphereGeometry(0.15, 8, 8);

                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-0.3, 1.8, 0.8);
                group.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(0.3, 1.8, 0.8);
                group.add(rightEye);
            } else if (type === 'boss') {
                // Giant dark beast
                const bodyGeo = new THREE.SphereGeometry(3, 16, 16);
                const bodyMat = new THREE.MeshPhongMaterial({
                    color: 0x1a0033,
                    transparent: true,
                    opacity: 0.9
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 3;
                body.castShadow = true;
                group.add(body);

                // Horns
                const hornGeo = new THREE.ConeGeometry(0.5, 2, 6);
                const hornMat = new THREE.MeshPhongMaterial({ color: 0x8B0000 });

                const leftHorn = new THREE.Mesh(hornGeo, hornMat);
                leftHorn.position.set(-1.5, 5, 0);
                leftHorn.rotation.z = 0.3;
                group.add(leftHorn);

                const rightHorn = new THREE.Mesh(hornGeo, hornMat);
                rightHorn.position.set(1.5, 5, 0);
                rightHorn.rotation.z = -0.3;
                group.add(rightHorn);

                // Giant eyes
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                const eyeGeo = new THREE.SphereGeometry(0.4, 8, 8);

                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-1, 4, 2.5);
                group.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(1, 4, 2.5);
                group.add(rightEye);
            }

            return group;
        }

        function spawnEnemy() {
            // Spawn from map edges
            const side = Math.floor(Math.random() * 4);
            let x, z;

            switch (side) {
                case 0: x = -40; z = Math.random() * 60 - 30; break;
                case 1: x = 40; z = Math.random() * 60 - 30; break;
                case 2: x = Math.random() * 60 - 30; z = -40; break;
                case 3: x = Math.random() * 60 - 30; z = 40; break;
            }

            const mesh = createEnemyMesh('dark_spirit');
            mesh.position.set(x, 0, z);
            scene.add(mesh);

            game.enemies.push({
                type: 'dark_spirit',
                hp: 20,
                maxHp: 20,
                mesh,
                x,
                z,
                speed: 5
            });
        }

        function spawnBoss() {
            if (game.bossSpawned) return;
            game.bossSpawned = true;

            const mesh = createEnemyMesh('boss');
            mesh.position.set(0, 0, -50);
            scene.add(mesh);

            game.enemies.push({
                type: 'boss',
                hp: CONFIG.bossHp,
                maxHp: CONFIG.bossHp,
                mesh,
                x: 0,
                z: -50,
                speed: 3
            });

            showPrompt('âš ï¸ æœ€ç»ˆBOSSå‡ºç°ï¼å‡†å¤‡æˆ˜æ–—ï¼');
        }

        // ==================== LOOT SYSTEM ====================
        function spawnLoot(x, z, type) {
            const group = new THREE.Group();

            if (type === 'meat') {
                const meatGeo = new THREE.SphereGeometry(0.5, 8, 8);
                const meatMat = new THREE.MeshPhongMaterial({ color: 0xCD5C5C });
                const meat = new THREE.Mesh(meatGeo, meatMat);
                meat.position.y = 0.5;
                meat.castShadow = true;
                group.add(meat);
            } else if (type === 'coin') {
                const coinGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16);
                const coinMat = new THREE.MeshPhongMaterial({ color: 0xFFD700 });
                const coin = new THREE.Mesh(coinGeo, coinMat);
                coin.rotation.x = Math.PI / 2;
                coin.position.y = 0.5;
                coin.castShadow = true;
                group.add(coin);
            }

            group.position.set(x, 0, z);
            scene.add(group);

            game.loot.push({ type, mesh: group, x, z });
        }

        // ==================== UI FUNCTIONS ====================
        function showPrompt(text) {
            const box = document.getElementById('promptBox');
            box.textContent = text;
            box.style.display = 'block';

            clearTimeout(box.hideTimeout);
            box.hideTimeout = setTimeout(() => {
                box.style.display = 'none';
            }, 3000);
        }

        function updateHUD() {
            document.getElementById('meatCount').textContent = Math.floor(game.meat);
            document.getElementById('coinCount').textContent = Math.floor(game.coins);
        }

        function updateBeastPanel() {
            const panel = document.getElementById('beastPanel');
            panel.innerHTML = '';

            game.beasts.forEach((beast) => {
                if (!beast.captured) return; // Only show captured beasts

                const card = document.createElement('div');
                card.className = 'beast-card' + (beast.stage !== 'baby' ? ' active' : '');

                const stageName = beast.stage === 'baby' ? 'å—ä¼¤' :
                    (beast.stage === 'healthy' ? 'å¥åº·' : 'å·¨å‹');
                const name = beast.type === 'hydra' ? 'ä¹å¤´è›‡' : 'é›·é¹é¸Ÿ';

                const canFeed = beast.stage !== 'evolved' && game.meat >= CONFIG.feedCost;
                const feedBtnText = beast.stage === 'evolved' ? 'å·²è¿›åŒ–' :
                    `ğŸ¥© å–‚é£Ÿ (${CONFIG.feedCost}è‚‰å—)`;

                card.innerHTML = `
                <div class="name">${beast.type === 'hydra' ? 'ğŸ' : 'ğŸ¦…'} ${name}</div>
                <div class="stage">çŠ¶æ€: ${stageName}</div>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${beast.feedProgress}%"></div>
                </div>
                <button class="feed-btn" 
                    ${!canFeed ? 'disabled' : ''}
                    onclick="feedBeastByType('${beast.type}')">
                    ${feedBtnText}
                </button>
            `;

                panel.appendChild(card);
            });
        }

        // Global feed function for button onclick - uses beast type as unique ID
        window.feedBeastByType = function (type) {
            const beast = game.beasts.find(b => b.type === type && b.captured);
            if (beast && beast.stage !== 'evolved') {
                feedBeast(beast);
            }
        };

        function showVictory() {
            document.getElementById('victoryScreen').style.display = 'flex';
        }

        // ==================== GAME FLOW ====================
        // 15-Step Sequence:
        // 1: Capture Hydra | 2: Feed Hydra | 3: Hydra Healthy
        // 4: Enemies spawn | 5: Build Meat Factory | 6: Thunderbird appears
        // 7: Capture Thunderbird | 8: Feed Thunderbird | 9: Build Worker Hut
        // 10: Upgrade Meat Factory | 11: Hydra evolves | 12: Thunderbird evolves
        // 13: Boss spawns | 14: Boss defeated | 15: Victory

        function advanceStep() {
            game.step++;
            console.log('Advancing to step:', game.step);

            switch (game.step) {
                case 2: // After capturing Hydra
                    showPrompt('ğŸ¥© ç”¨è‚‰å—å–‚å…»ä¹å¤´è›‡ï¼é è¿‘å®ƒå³å¯å–‚é£Ÿ');
                    break;
                case 3: // Hydra becomes healthy
                    // Triggers enemy spawning
                    break;
                case 4: // Enemies start spawning
                    showPrompt('âš”ï¸ é»‘æš—çµæ¥è¢­ï¼ä¹å¤´è›‡ä¼šè‡ªåŠ¨æ”»å‡»ï¼å‡»æ€è·å¾—é‡‘å¸');
                    break;
                case 5: // Can build meat factory (need 50 coins)
                    showPrompt('ğŸ—ï¸ æ”¶é›†50é‡‘å¸åï¼Œèµ°åˆ°å»ºç­‘ç‚¹å»ºé€ é€ è‚‰å‚ï¼');
                    break;
                case 6: // Thunderbird appears after meat factory built
                    setTimeout(() => spawnThunderbird(), 2000);
                    break;
                case 7: // After capturing Thunderbird
                    showPrompt('ğŸ¥© ç”¨é€ è‚‰å‚äº§å‡ºçš„è‚‰å—å–‚å…»é›·é¹é¸Ÿï¼');
                    break;
                case 8: // Thunderbird healthy
                    showPrompt('ğŸ’ª é›·é¹é¸Ÿæ¢å¤å¥åº·ï¼æ”¶é›†80é‡‘å¸å»ºé€ å·¥äººå°å±‹');
                    break;
                case 9: // After building worker hut
                    showPrompt('â¬†ï¸ æ”¶é›†100é‡‘å¸å‡çº§é€ è‚‰å‚ï¼');
                    break;
                case 10: // After upgrading meat factory
                    showPrompt('ğŸ ç»§ç»­å–‚å…»ä¹å¤´è›‡è®©å®ƒè¿›åŒ–ï¼');
                    break;
                case 11: // Hydra evolved
                    showPrompt('âš¡ ä¹å¤´è›‡è¿›åŒ–æˆå·¨å‹ï¼ç»§ç»­å–‚å…»é›·é¹é¸Ÿï¼');
                    break;
                case 12: // Thunderbird evolved
                    showPrompt('ğŸŒŸ åŒå·¨å…½è¿›åŒ–å®Œæˆï¼å‡†å¤‡è¿æˆ˜æœ€ç»ˆBOSSï¼');
                    break;
                case 13: // Boss spawns
                    setTimeout(() => spawnBoss(), CONFIG.bossSpawnDelay * 1000);
                    break;
                case 14: // Boss defeated
                    advanceStep(); // Auto-advance to victory
                    break;
                case 15: // Victory
                    setTimeout(showVictory, 2000);
                    break;
            }
        }

        // ==================== GAME UPDATE ====================
        function update(dt) {
            if (!game.started) return;

            // Player movement
            let moveX = 0, moveZ = 0;

            if (keys.w) moveZ -= 1;
            if (keys.s) moveZ += 1;
            if (keys.a) moveX -= 1;
            if (keys.d) moveX += 1;

            // Apply joystick
            moveX += joystickVector.x;
            moveZ -= joystickVector.y;

            // Normalize
            const len = Math.sqrt(moveX * moveX + moveZ * moveZ);
            if (len > 0) {
                moveX /= len;
                moveZ /= len;

                player.x += moveX * CONFIG.playerSpeed * dt;
                player.z += moveZ * CONFIG.playerSpeed * dt;

                // Clamp to bounds
                player.x = Math.max(-35, Math.min(35, player.x));
                player.z = Math.max(-35, Math.min(35, player.z));

                playerMesh.position.set(player.x, 0, player.z);

                // Face movement direction
                playerMesh.rotation.y = Math.atan2(moveX, -moveZ);
            }

            // Camera follows player
            camera.position.x = player.x;
            camera.position.z = player.z + 40;
            camera.lookAt(player.x, 0, player.z);

            // Check interactions
            checkBeastInteractions();
            checkBuildingInteractions();
            checkLootCollection();

            // Update beasts
            updateBeasts(dt);

            // Update projectiles
            updateProjectiles(dt);

            // Update enemies
            updateEnemies(dt);

            // Update workers
            updateWorkers(dt);

            // Meat production
            if (game.meatFactoryBuilt) {
                game.meatProductionTimer += dt;
                const rate = game.meatFactoryUpgraded ? CONFIG.meatProductionRateUpgraded : CONFIG.meatProductionRate;
                if (game.meatProductionTimer >= 1) {
                    game.meat += rate;
                    game.meatProductionTimer = 0;
                    updateHUD();
                }
            }

            // Enemy spawning (after step 4)
            if (game.step >= 4 && !game.bossDefeated) {
                game.enemySpawnTimer += dt;
                if (game.enemySpawnTimer >= CONFIG.enemySpawnInterval) {
                    spawnEnemy();
                    game.enemySpawnTimer = 0;
                }
            }

            // Update building label visibility based on step
            updateBuildingLabels();
        }

        function checkBeastInteractions() {
            game.beasts.forEach(beast => {
                const dx = player.x - beast.x;
                const dz = player.z - beast.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                // Capture
                if (!beast.captured && dist < 3) {
                    captureBeast(beast);
                }

                // NOTE: Feeding now requires clicking the button in beast panel
            });
        }

        function checkBuildingInteractions() {
            // Meat factory spot - available after enemies spawn (step 4)
            // Building it advances to step 5, triggering thunderbird spawn
            if (!game.meatFactoryBuilt && game.step >= 4) {
                const dx = player.x - 15;
                const dz = player.z - 10;
                if (Math.sqrt(dx * dx + dz * dz) < 5) {
                    buildMeatFactory();
                }
            }

            // Worker hut spot - available after thunderbird healthy (step 8)
            // Building it advances to step 9
            if (!game.workerHutBuilt && game.step >= 8) {
                const dx = player.x - 15;
                const dz = player.z + 5;
                if (Math.sqrt(dx * dx + dz * dz) < 5) {
                    buildWorkerHut();
                }
            }

            // Upgrade meat factory - available after worker hut built (step 9)
            // Upgrading it advances to step 10
            if (game.meatFactoryBuilt && !game.meatFactoryUpgraded && game.step >= 9) {
                const dx = player.x - 15;
                const dz = player.z - 10;
                if (Math.sqrt(dx * dx + dz * dz) < 5) {
                    upgradeMeatFactory();
                }
            }
        }

        function checkLootCollection() {
            for (let i = game.loot.length - 1; i >= 0; i--) {
                const loot = game.loot[i];
                const dx = player.x - loot.x;
                const dz = player.z - loot.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < CONFIG.collectRange) {
                    if (loot.type === 'meat') game.meat += 2;
                    else if (loot.type === 'coin') game.coins += 15; // Increased from 5 to 15

                    scene.remove(loot.mesh);
                    game.loot.splice(i, 1);
                    updateHUD();
                }
            }
        }

        function updateBeasts(dt) {
            game.beasts.forEach(beast => {
                // Decrease feed cooldown
                if (beast.feedCooldown) {
                    beast.feedCooldown -= dt;
                    if (beast.feedCooldown <= 0) beast.feedCooldown = 0;
                }

                // Only act if captured and healthy/evolved
                if (beast.captured && beast.stage !== 'baby') {
                    beast.attackCooldown -= dt;

                    // Find nearest enemy
                    let nearest = null;
                    let nearestDist = Infinity;

                    game.enemies.forEach(enemy => {
                        const dx = beast.x - enemy.x;
                        const dz = beast.z - enemy.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = enemy;
                        }
                    });

                    // Auto-move towards distant enemies
                    if (nearest && nearestDist > CONFIG.beastAttackRange) {
                        const dx = nearest.x - beast.x;
                        const dz = nearest.z - beast.z;
                        const moveSpeed = CONFIG.beastMoveSpeed * dt;

                        beast.x += (dx / nearestDist) * moveSpeed;
                        beast.z += (dz / nearestDist) * moveSpeed;
                        beast.mesh.position.set(beast.x, 0, beast.z);

                        // Face direction of movement
                        beast.mesh.rotation.y = Math.atan2(dx, dz);
                    }

                    // Ranged attack if in range
                    if (nearest && nearestDist <= CONFIG.beastAttackRange && beast.attackCooldown <= 0) {
                        // Fire projectile!
                        const damage = CONFIG.beastAttackDamage[beast.stage];
                        fireProjectile(beast, nearest, damage);
                        beast.attackCooldown = beast.stage === 'evolved' ? 0.5 : 0.8;

                        // Face target
                        const dx = nearest.x - beast.x;
                        const dz = nearest.z - beast.z;
                        beast.mesh.rotation.y = Math.atan2(dx, dz);
                    }
                }

                // Idle animation when no enemies
                if (game.enemies.length === 0 && beast.captured && beast.stage !== 'baby') {
                    beast.mesh.rotation.y += dt * 0.3;
                }
            });
        }

        // Create and fire a ranged projectile from beast to enemy
        function fireProjectile(beast, target, damage) {
            const color = beast.type === 'hydra' ? 0x00FF00 : 0x00BFFF; // Green for hydra, blue for thunderbird
            const size = beast.stage === 'evolved' ? 0.8 : 0.4;

            const geo = new THREE.SphereGeometry(size, 8, 8);
            const mat = new THREE.MeshBasicMaterial({
                color: color,
                emissive: color,
                transparent: true,
                opacity: 0.9
            });
            const projectile = new THREE.Mesh(geo, mat);
            projectile.position.set(beast.x, 2, beast.z);
            scene.add(projectile);

            game.projectiles.push({
                mesh: projectile,
                x: beast.x,
                y: 2,
                z: beast.z,
                targetEnemy: target,
                damage: damage,
                speed: 40
            });
        }

        function updateProjectiles(dt) {
            for (let i = game.projectiles.length - 1; i >= 0; i--) {
                const proj = game.projectiles[i];

                // Check if target still exists
                if (!proj.targetEnemy || !game.enemies.includes(proj.targetEnemy)) {
                    scene.remove(proj.mesh);
                    game.projectiles.splice(i, 1);
                    continue;
                }

                // Move towards target
                const dx = proj.targetEnemy.x - proj.x;
                const dy = 1 - proj.y;
                const dz = proj.targetEnemy.z - proj.z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (dist < 1.5) {
                    // Hit!
                    proj.targetEnemy.hp -= proj.damage;

                    // Hit effect
                    createHitEffect(proj.x, proj.z);

                    scene.remove(proj.mesh);
                    game.projectiles.splice(i, 1);
                } else {
                    // Move projectile
                    const moveAmount = proj.speed * dt;
                    proj.x += (dx / dist) * moveAmount;
                    proj.y += (dy / dist) * moveAmount;
                    proj.z += (dz / dist) * moveAmount;
                    proj.mesh.position.set(proj.x, proj.y, proj.z);
                }
            }
        }

        function createHitEffect(x, z) {
            const geo = new THREE.RingGeometry(0.5, 1.5, 16);
            const mat = new THREE.MeshBasicMaterial({
                color: 0xFFFF00,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(geo, mat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.set(x, 0.5, z);
            scene.add(ring);

            // Animate and remove
            let scale = 1;
            const animate = () => {
                scale += 0.3;
                ring.scale.set(scale, scale, scale);
                mat.opacity -= 0.15;
                if (mat.opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(ring);
                }
            };
            animate();
        }

        function updateEnemies(dt) {
            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const enemy = game.enemies[i];

                // Move towards center/player
                const targetX = player.x;
                const targetZ = player.z;
                const dx = targetX - enemy.x;
                const dz = targetZ - enemy.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist > 2) {
                    enemy.x += (dx / dist) * enemy.speed * dt;
                    enemy.z += (dz / dist) * enemy.speed * dt;
                    enemy.mesh.position.set(enemy.x, 0, enemy.z);
                }

                // Check if dead
                if (enemy.hp <= 0) {
                    scene.remove(enemy.mesh);

                    // Drop loot
                    spawnLoot(enemy.x + (Math.random() - 0.5) * 2, enemy.z + (Math.random() - 0.5) * 2, 'coin');
                    if (Math.random() < 0.3) {
                        spawnLoot(enemy.x + (Math.random() - 0.5) * 2, enemy.z + (Math.random() - 0.5) * 2, 'meat');
                    }

                    // Check if boss
                    if (enemy.type === 'boss') {
                        game.bossDefeated = true;
                        showPrompt('ğŸ† BOSSè¢«å‡»è´¥ï¼èƒœåˆ©ï¼');
                        advanceStep();
                    }

                    game.enemies.splice(i, 1);
                }

                // Animate
                enemy.mesh.rotation.y += dt * 2;
            }
        }

        function updateWorkers(dt) {
            game.workers.forEach(worker => {
                // Find nearest unclaimed loot
                if (!worker.targetLoot || !game.loot.includes(worker.targetLoot)) {
                    let nearest = null;
                    let nearestDist = 50;

                    game.loot.forEach(loot => {
                        const dx = worker.x - loot.x;
                        const dz = worker.z - loot.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = loot;
                        }
                    });

                    worker.targetLoot = nearest;
                }

                // Move towards loot
                if (worker.targetLoot) {
                    const dx = worker.targetLoot.x - worker.x;
                    const dz = worker.targetLoot.z - worker.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist > 0.5) {
                        worker.x += (dx / dist) * 8 * dt;
                        worker.z += (dz / dist) * 8 * dt;
                        worker.mesh.position.set(worker.x, 0, worker.z);
                    } else {
                        // Collect
                        if (worker.targetLoot.type === 'meat') game.meat += 2;
                        else if (worker.targetLoot.type === 'coin') game.coins += 15; // Increased from 5 to 15

                        scene.remove(worker.targetLoot.mesh);
                        const idx = game.loot.indexOf(worker.targetLoot);
                        if (idx >= 0) game.loot.splice(idx, 1);

                        worker.targetLoot = null;
                        updateHUD();
                    }
                }
            });
        }

        // ==================== INPUT HANDLING ====================
        function initInput() {
            // Keyboard
            document.addEventListener('keydown', e => {
                if (e.key.toLowerCase() === 'w') keys.w = true;
                if (e.key.toLowerCase() === 'a') keys.a = true;
                if (e.key.toLowerCase() === 's') keys.s = true;
                if (e.key.toLowerCase() === 'd') keys.d = true;

                startGame();
            });

            document.addEventListener('keyup', e => {
                if (e.key.toLowerCase() === 'w') keys.w = false;
                if (e.key.toLowerCase() === 'a') keys.a = false;
                if (e.key.toLowerCase() === 's') keys.s = false;
                if (e.key.toLowerCase() === 'd') keys.d = false;
            });

            // Joystick
            joystick = nipplejs.create({
                zone: document.getElementById('joystickZone'),
                mode: 'static',
                position: { left: '75px', bottom: '75px' },
                color: '#4CAF50',
                size: 120
            });

            joystick.on('move', (evt, data) => {
                const force = Math.min(data.force, 1);
                const angle = data.angle.radian;
                joystickVector.x = Math.cos(angle) * force;
                joystickVector.y = Math.sin(angle) * force;

                startGame();
            });

            joystick.on('end', () => {
                joystickVector.x = 0;
                joystickVector.y = 0;
            });

            // Tutorial click
            document.getElementById('tutorialOverlay').addEventListener('click', startGame);
        }

        function startGame() {
            if (game.started) return;
            game.started = true;
            document.getElementById('tutorialOverlay').style.display = 'none';
        }

        // ==================== WINDOW RESIZE ====================
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const viewSize = 40;

            camera.left = -viewSize * aspect;
            camera.right = viewSize * aspect;
            camera.top = viewSize;
            camera.bottom = -viewSize;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== GAME LOOP ====================
        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            update(dt);

            renderer.render(scene, camera);
        }

        // ==================== INIT ====================
        function init() {
            initThreeJS();
            initInput();
            updateHUD();
            updateBeastPanel();
            animate();
        }

        init();
    </script>
</body>

</html>